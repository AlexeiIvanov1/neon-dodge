<!doctype html>
<html lang="en" data-theme="dark">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Neon Dodge 2077</title>
  <style>
    @import url("https://fonts.googleapis.com/css2?family=Chakra+Petch:wght@400;600;700&family=Orbitron:wght@500;700;800&display=swap");

    :root {
      --font-display: "Orbitron", sans-serif;
      --font-body: "Chakra Petch", sans-serif;
      --bg-0: #04070f;
      --bg-1: #071024;
      --bg-2: #0b1e3a;
      --panel: #0b1326c4;
      --ink: #d6f4ff;
      --muted: #8db4d0;
      --primary: #23f7ff;
      --secondary: #ff5b9f;
      --danger: #ff4f6c;
      --grid: #2ef8ff3d;
      --glow: #23f7ff88;
      --frame: #3ff9ff66;
    }

    html[data-theme="bright"] {
      --bg-0: #d5f7ff;
      --bg-1: #a7e5ff;
      --bg-2: #c2fff3;
      --panel: #f4fdffe6;
      --ink: #0f1d33;
      --muted: #365d75;
      --primary: #006dff;
      --secondary: #ff0077;
      --danger: #ff2f4b;
      --grid: #1566ff2a;
      --glow: #006dff5e;
      --frame: #1972ff5e;
    }

    * {
      box-sizing: border-box;
    }

    html,
    body {
      margin: 0;
      min-height: 100%;
      color: var(--ink);
      font-family: var(--font-body);
      overflow: hidden;
      background:
        radial-gradient(1300px 700px at 12% 6%, color-mix(in srgb, var(--primary) 20%, transparent), transparent 70%),
        radial-gradient(900px 500px at 90% 85%, color-mix(in srgb, var(--secondary) 24%, transparent), transparent 72%),
        linear-gradient(160deg, var(--bg-0), var(--bg-1) 52%, var(--bg-2));
    }

    body::before,
    body::after {
      content: "";
      position: fixed;
      inset: 0;
      pointer-events: none;
      z-index: 1;
    }

    body::before {
      background: repeating-linear-gradient(
        0deg,
        transparent,
        transparent 2px,
        color-mix(in srgb, var(--ink) 5%, transparent) 3px,
        transparent 4px
      );
      opacity: 0.32;
      animation: scanline 8s linear infinite;
    }

    body::after {
      background: radial-gradient(circle at 60% 30%, color-mix(in srgb, var(--primary) 16%, transparent), transparent 42%);
      mix-blend-mode: screen;
      animation: pulse 4.6s ease-in-out infinite;
    }

    #matrixRain {
      position: fixed;
      inset: 0;
      width: 100vw;
      height: 100vh;
      z-index: 0;
      pointer-events: none;
      opacity: 0.62;
    }

    .shell {
      width: min(96vw, 1060px);
      margin: clamp(10px, 2vw, 24px) auto;
      position: relative;
      z-index: 2;
      border: 1px solid var(--frame);
      border-radius: 16px;
      padding: clamp(10px, 1.7vw, 18px);
      background: linear-gradient(120deg, color-mix(in srgb, var(--panel) 88%, transparent), color-mix(in srgb, var(--panel) 72%, transparent));
      box-shadow: 0 24px 70px #0000005e, inset 0 0 28px color-mix(in srgb, var(--primary) 10%, transparent);
      backdrop-filter: blur(10px);
    }

    .hud {
      display: flex;
      gap: 12px;
      justify-content: space-between;
      align-items: center;
      flex-wrap: wrap;
      margin-bottom: 10px;
    }

    .title {
      font-family: var(--font-display);
      font-weight: 800;
      letter-spacing: 0.1em;
      text-transform: uppercase;
      font-size: clamp(1.1rem, 2.5vw, 1.9rem);
      position: relative;
      text-shadow: 0 0 22px var(--glow);
      animation: glitch 2.8s infinite;
    }

    .title::before,
    .title::after {
      content: attr(data-text);
      position: absolute;
      inset: 0;
      pointer-events: none;
      opacity: 0.6;
    }

    .title::before {
      color: color-mix(in srgb, var(--secondary) 80%, transparent);
      transform: translate(1.5px, -1px);
      clip-path: polygon(0 5%, 100% 0, 100% 36%, 0 40%);
    }

    .title::after {
      color: color-mix(in srgb, var(--primary) 88%, transparent);
      transform: translate(-1px, 1px);
      clip-path: polygon(0 62%, 100% 58%, 100% 100%, 0 100%);
    }

    .controls {
      display: flex;
      align-items: center;
      gap: 8px;
      flex-wrap: wrap;
      justify-content: flex-end;
    }

    .chip,
    select,
    button {
      border: 1px solid color-mix(in srgb, var(--primary) 55%, transparent);
      background: color-mix(in srgb, var(--bg-0) 55%, transparent);
      color: var(--ink);
      border-radius: 10px;
      padding: 0.42rem 0.62rem;
      font: 600 0.9rem var(--font-body);
    }

    select,
    button {
      cursor: pointer;
    }

    button:hover,
    select:hover {
      filter: brightness(1.08);
    }

    .chip {
      text-transform: uppercase;
      letter-spacing: 0.04em;
      font-size: 0.78rem;
      color: var(--muted);
    }

    .arena {
      position: relative;
    }

    canvas {
      width: 100%;
      aspect-ratio: 16 / 9;
      display: block;
      border: 1px solid var(--frame);
      border-radius: 14px;
      background: #020611;
      box-shadow: inset 0 0 45px #0ff2;
    }

    .status {
      margin-top: 10px;
      display: flex;
      justify-content: space-between;
      gap: 8px;
      color: var(--muted);
      font-size: 0.95rem;
      flex-wrap: wrap;
    }

    @keyframes glitch {
      0%, 85%, 100% { transform: translate(0, 0); }
      87% { transform: translate(1px, -1px); }
      89% { transform: translate(-2px, 1px); }
      91% { transform: translate(2px, 0); }
      93% { transform: translate(-1px, -1px); }
    }

    @keyframes scanline {
      from { transform: translateY(0); }
      to { transform: translateY(22px); }
    }

    @keyframes pulse {
      0%, 100% { opacity: 0.35; }
      50% { opacity: 0.6; }
    }

    @media (max-width: 720px) {
      .controls {
        justify-content: flex-start;
      }
    }
  </style>
</head>
<body>
  <canvas id="matrixRain" aria-hidden="true"></canvas>

  <main class="shell">
    <header class="hud">
      <div class="title" data-text="Neon Dodge 2077">Neon Dodge 2077</div>
      <div class="controls">
        <span class="chip">Theme</span>
        <select id="themeSelect" aria-label="Theme selector">
          <option value="dark">Dark</option>
          <option value="bright">Bright</option>
        </select>
        <span class="chip">Zone</span>
        <select id="biomeSelect" aria-label="Zone selector">
          <option value="auto">Auto</option>
          <option value="city">Neon City</option>
          <option value="metro">Metro Tunnel</option>
        </select>
        <span class="chip">Audio</span>
        <select id="musicSelect" aria-label="Music selector">
          <option value="off">Off</option>
          <option value="night_runner">Night Runner</option>
          <option value="chrome_heist">Chrome Heist</option>
          <option value="sunset_grid">Sunset Grid</option>
          <option value="overclock">Overclock</option>
        </select>
        <button id="restart">Restart</button>
      </div>
    </header>

    <section class="arena">
      <canvas id="game" width="960" height="540" aria-label="Neon Dodge game area"></canvas>
    </section>

    <footer class="status">
      <span id="help">Move with Arrow Keys / WASD, press R to restart.</span>
      <span id="missionState">Objective: Sync signal</span>
      <span id="biomeState">Zone: Neon City</span>
      <span id="batteryState">Battery: 100%</span>
      <span id="audioState">Audio: Off</span>
    </footer>
  </main>

  <script>
    const matrixCanvas = document.getElementById("matrixRain");
    const matrixCtx = matrixCanvas.getContext("2d");
    const canvas = document.getElementById("game");
    const ctx = canvas.getContext("2d");
    const restartButton = document.getElementById("restart");
    const themeSelect = document.getElementById("themeSelect");
    const biomeSelect = document.getElementById("biomeSelect");
    const musicSelect = document.getElementById("musicSelect");
    const missionState = document.getElementById("missionState");
    const biomeState = document.getElementById("biomeState");
    const batteryState = document.getElementById("batteryState");
    const audioState = document.getElementById("audioState");

    const THEME_KEY = "neon_dodge_theme";
    const BIOME_MODE_KEY = "neon_dodge_biome_mode";

    const state = {
      player: { x: 120, y: 270, r: 14, speed: 5.3, facingX: 1, facingY: 0 },
      enemies: [],
      particles: [],
      pickups: [],
      shots: [],
      weatherEvents: [],
      keys: new Set(),
      score: 0,
      best: Number(localStorage.getItem("neon_dodge_best") || 0),
      spawnTimer: 0,
      pickupTimer: 420,
      weatherCooldown: 320,
      running: true,
      tick: 0,
      biome: "city",
      biomeMode: "auto",
      biomeTimer: 1600,
      battery: 100,
      missionsCompleted: 0,
      missionPhase: "travel",
      missionProgress: 0,
      missionTarget: 700,
      extraction: null,
      cause: "",
    };

    let audioCtx;
    let masterGain;
    let sequenceTimer;
    let beatIndex = 0;

    const matrix = {
      fontSize: 16,
      chars: "01@#$%&*+-<>[]{}ABCDEFGHIJKLMNOPQRSTUVWXYZ".split(""),
      drops: [],
    };

    const tracks = {
      night_runner: {
        bpm: 126,
        lead: [0, 7, 10, 7, 12, 7, 10, 7, 3, 7, 10, 7, 15, 10, 7, 3],
        bass: [0, 0, -5, -5, -3, -3, -5, -5],
      },
      chrome_heist: {
        bpm: 138,
        lead: [7, 12, 10, 7, 5, 10, 8, 5, 12, 15, 12, 8, 10, 12, 8, 5],
        bass: [0, -3, -5, -3, 0, -3, -7, -3],
      },
      sunset_grid: {
        bpm: 110,
        lead: [0, 4, 7, 11, 9, 7, 4, 2, 0, 2, 4, 7, 9, 11, 7, 4],
        bass: [0, -7, -5, -3, 0, -7, -10, -5],
      },
      overclock: {
        bpm: 148,
        lead: [0, 12, 7, 15, 10, 17, 12, 19, 7, 15, 10, 17, 3, 10, 7, 12],
        bass: [0, -3, -7, -10, -5, -8, -12, -7],
      },
    };

    function setTheme(theme) {
      document.documentElement.setAttribute("data-theme", theme);
      themeSelect.value = theme;
      localStorage.setItem(THEME_KEY, theme);
    }

    function applyBiomeMode(mode) {
      state.biomeMode = mode;
      biomeSelect.value = mode;
      localStorage.setItem(BIOME_MODE_KEY, mode);

      if (mode === "city") {
        state.biome = "city";
      } else if (mode === "metro") {
        state.biome = "metro";
      } else {
        state.biomeTimer = 900;
      }
    }

    function zoneName() {
      return state.biome === "city" ? "Neon City" : "Metro Tunnel";
    }

    function updateHud() {
      if (state.missionPhase === "travel") {
        const pct = Math.min(100, Math.floor((state.missionProgress / state.missionTarget) * 100));
        missionState.textContent = `Objective: Sync signal ${pct}%`;
      } else {
        const holdPct = state.extraction
          ? Math.min(100, Math.floor((state.extraction.hold / state.extraction.holdNeed) * 100))
          : 0;
        const timer = state.extraction ? Math.ceil(state.extraction.timer / 60) : 0;
        missionState.textContent = `Objective: Reach extraction ${holdPct}% (${timer}s)`;
      }
      biomeState.textContent = `Zone: ${zoneName()}`;
      batteryState.textContent = `Battery: ${Math.round(state.battery)}%`;
      batteryState.style.color = state.battery < 22 ? "var(--danger)" : "var(--muted)";
    }

    function resizeMatrix() {
      matrixCanvas.width = window.innerWidth;
      matrixCanvas.height = window.innerHeight;
      const cols = Math.ceil(matrixCanvas.width / matrix.fontSize);
      matrix.drops = Array.from({ length: cols }, () => Math.random() * matrixCanvas.height / matrix.fontSize);
      matrixCtx.font = `${matrix.fontSize}px Chakra Petch, monospace`;
    }

    function drawMatrix() {
      const darkTheme = document.documentElement.getAttribute("data-theme") === "dark";
      const fade = darkTheme ? "rgba(3, 8, 14, 0.18)" : "rgba(211, 242, 255, 0.2)";
      const trail = darkTheme ? "#37ff9f" : "#0f58ff";
      const head = darkTheme ? "#d8ffe8" : "#162d70";

      matrixCtx.fillStyle = fade;
      matrixCtx.fillRect(0, 0, matrixCanvas.width, matrixCanvas.height);

      for (let i = 0; i < matrix.drops.length; i += 1) {
        const x = i * matrix.fontSize;
        const y = matrix.drops[i] * matrix.fontSize;
        const char = matrix.chars[Math.floor(Math.random() * matrix.chars.length)];

        matrixCtx.fillStyle = Math.random() > 0.9 ? head : trail;
        matrixCtx.fillText(char, x, y);

        if (y > matrixCanvas.height && Math.random() > 0.975) {
          matrix.drops[i] = 0;
        } else {
          matrix.drops[i] += 0.8 + Math.random() * 0.75;
        }
      }
    }

    function freqFromSemitone(root, offset) {
      return root * Math.pow(2, offset / 12);
    }

    function ensureAudio() {
      if (!audioCtx) {
        audioCtx = new AudioContext();
        masterGain = audioCtx.createGain();
        masterGain.gain.value = 0.16;
        masterGain.connect(audioCtx.destination);
      }
      if (audioCtx.state === "suspended") {
        audioCtx.resume();
      }
    }

    function synthHit({ freq, time, dur, type, gain, detune = 0 }) {
      const osc = audioCtx.createOscillator();
      const env = audioCtx.createGain();

      osc.type = type;
      osc.frequency.setValueAtTime(freq, time);
      osc.detune.setValueAtTime(detune, time);

      env.gain.setValueAtTime(0.0001, time);
      env.gain.exponentialRampToValueAtTime(gain, time + 0.01);
      env.gain.exponentialRampToValueAtTime(0.0001, time + dur);

      osc.connect(env);
      env.connect(masterGain);
      osc.start(time);
      osc.stop(time + dur + 0.03);
    }

    function triggerKick(time) {
      const osc = audioCtx.createOscillator();
      const env = audioCtx.createGain();
      osc.type = "sine";
      osc.frequency.setValueAtTime(130, time);
      osc.frequency.exponentialRampToValueAtTime(45, time + 0.12);
      env.gain.setValueAtTime(0.0001, time);
      env.gain.exponentialRampToValueAtTime(0.2, time + 0.01);
      env.gain.exponentialRampToValueAtTime(0.0001, time + 0.18);
      osc.connect(env);
      env.connect(masterGain);
      osc.start(time);
      osc.stop(time + 0.2);
    }

    function stopMusic() {
      if (sequenceTimer) {
        clearInterval(sequenceTimer);
        sequenceTimer = null;
      }
      audioState.textContent = "Audio: Off";
    }

    function startMusic(trackName) {
      if (trackName === "off") {
        stopMusic();
        return;
      }

      ensureAudio();
      if (sequenceTimer) clearInterval(sequenceTimer);

      const track = tracks[trackName];
      const stepMs = (60_000 / track.bpm) / 2;
      beatIndex = 0;
      audioState.textContent = `Audio: ${musicSelect.options[musicSelect.selectedIndex].text}`;

      sequenceTimer = setInterval(() => {
        if (!audioCtx) return;
        const now = audioCtx.currentTime;
        const leadStep = beatIndex % track.lead.length;
        const bassStep = beatIndex % track.bass.length;

        const leadFreq = freqFromSemitone(220, track.lead[leadStep]);
        const bassFreq = freqFromSemitone(110, track.bass[bassStep]);

        synthHit({ freq: leadFreq, time: now, dur: 0.16, type: "square", gain: 0.035 });
        synthHit({ freq: leadFreq * 2, time: now, dur: 0.08, type: "triangle", gain: 0.012, detune: 4 });

        if (beatIndex % 2 === 0) {
          synthHit({ freq: bassFreq, time: now, dur: 0.22, type: "sawtooth", gain: 0.028 });
        }

        if (beatIndex % 4 === 0) {
          triggerKick(now);
        }

        beatIndex += 1;
      }, stepMs);
    }

    function burst(x, y, color) {
      for (let i = 0; i < 9; i += 1) {
        const angle = Math.random() * Math.PI * 2;
        const speed = 1.2 + Math.random() * 3.1;
        state.particles.push({
          x,
          y,
          vx: Math.cos(angle) * speed,
          vy: Math.sin(angle) * speed,
          life: 26 + Math.random() * 24,
          color,
        });
      }
    }

    function endRun(cause) {
      if (!state.running) return;
      state.running = false;
      state.cause = cause;
      state.best = Math.max(state.best, Math.floor(state.score));
      localStorage.setItem("neon_dodge_best", String(state.best));
      burst(state.player.x, state.player.y, "#ff5b9f");
    }

    function switchBiome() {
      if (state.biomeMode !== "auto") return;
      state.biome = state.biome === "city" ? "metro" : "city";
      state.biomeTimer = 1400 + Math.floor(Math.random() * 500);
      state.weatherCooldown = 120 + Math.floor(Math.random() * 180);
      burst(canvas.width * 0.72, canvas.height * 0.24, state.biome === "city" ? "#23f7ff" : "#d8ffe8");
    }

    function startExtraction() {
      const h = 96;
      const w = 128;
      const y = 68 + Math.random() * (canvas.height - h - 136);
      state.extraction = {
        x: canvas.width - 180,
        y,
        w,
        h,
        hold: 0,
        holdNeed: 96,
        timer: 820,
      };
      state.missionPhase = "extract";
      burst(canvas.width - 120, y + h * 0.5, "#8dd7ff");
    }

    function completeExtraction() {
      state.missionsCompleted += 1;
      state.missionPhase = "travel";
      state.missionProgress = 0;
      state.missionTarget = Math.min(1700, 700 + state.missionsCompleted * 170);
      state.battery = Math.min(100, state.battery + 16);
      state.extraction = null;
      if (state.enemies.length > 6) {
        state.enemies.splice(0, Math.floor(state.enemies.length * 0.45));
      }
      burst(state.player.x + 40, state.player.y, "#23f7ff");
      burst(state.player.x + 70, state.player.y - 20, "#8effcf");
    }

    function reset() {
      state.player.x = 120;
      state.player.y = canvas.height / 2;
      state.player.facingX = 1;
      state.player.facingY = 0;
      state.enemies = [];
      state.particles = [];
      state.pickups = [];
      state.shots = [];
      state.weatherEvents = [];
      state.score = 0;
      state.spawnTimer = 0;
      state.pickupTimer = 420;
      state.weatherCooldown = 320;
      state.running = true;
      state.tick = 0;
      state.biome = state.biomeMode === "metro" ? "metro" : "city";
      state.biomeTimer = 1600;
      state.battery = 100;
      state.missionsCompleted = 0;
      state.missionPhase = "travel";
      state.missionProgress = 0;
      state.missionTarget = 700;
      state.extraction = null;
      state.cause = "";
    }

    function updateMission() {
      if (!state.running) return;

      if (state.missionPhase === "travel") {
        state.missionProgress += 1 + state.score / 4000;
        if (state.missionProgress >= state.missionTarget) {
          startExtraction();
        }
        return;
      }

      if (!state.extraction) {
        startExtraction();
        return;
      }

      state.extraction.timer -= 1;
      if (state.extraction.timer <= 0) {
        endRun("Missed extraction window");
        return;
      }

      const e = state.extraction;
      const px = state.player.x;
      const py = state.player.y;
      const inside = px > e.x && px < e.x + e.w && py > e.y && py < e.y + e.h;

      if (inside) {
        e.hold = Math.min(e.holdNeed, e.hold + 1.4);
        if (state.tick % 4 === 0) burst(px + Math.random() * 8, py + Math.random() * 8, "#8de5ff");
      } else {
        e.hold = Math.max(0, e.hold - 1);
      }

      if (e.hold >= e.holdNeed) {
        completeExtraction();
      }
    }

    function spawnEnemy() {
      const roll = Math.random();
      const inCity = state.biome === "city";
      let type = "drone";

      if (inCity) {
        if (roll > 0.72) type = "turret";
        if (roll > 0.9) type = "mutant";
      } else {
        if (roll < 0.56) type = "mutant";
        else if (roll > 0.8) type = "turret";
      }

      const radiusByType = { drone: 14, mutant: 19, turret: 16 };
      const speedByType = { drone: 4.2, mutant: 3.25, turret: 2.8 };
      const r = radiusByType[type] + Math.random() * 8;

      state.enemies.push({
        type,
        x: canvas.width + r,
        y: r + Math.random() * (canvas.height - r * 2),
        r,
        speed: speedByType[type] + Math.random() * 1.7 + state.score / 500,
        phase: Math.random() * Math.PI * 2,
        cooldown: 90 + Math.random() * 80,
        charge: 0,
        chargeVy: 0,
        fireCd: 70 + Math.random() * 80,
        lock: 0,
        aimX: 0,
        aimY: 0,
      });
    }

    function spawnShot(enemy) {
      const tx = enemy.aimX || state.player.x;
      const ty = enemy.aimY || state.player.y;
      const angle = Math.atan2(ty - enemy.y, tx - enemy.x);
      state.shots.push({
        x: enemy.x,
        y: enemy.y,
        vx: Math.cos(angle) * 6.2,
        vy: Math.sin(angle) * 6.2,
        r: 4,
      });
      burst(enemy.x, enemy.y, "#ff9b4f");
    }

    function spawnWeatherEvent() {
      if (state.biome === "city") {
        const width = 28 + Math.random() * 50;
        state.weatherEvents.push({
          type: "storm",
          x: 140 + Math.random() * (canvas.width - 220),
          width,
          warn: 68,
          strike: 22,
        });
      } else {
        const r = 38 + Math.random() * 30;
        state.weatherEvents.push({
          type: "gas",
          x: canvas.width + r,
          y: 60 + Math.random() * (canvas.height - 120),
          r,
          life: 360,
          drift: -(1.1 + Math.random() * 1.1),
        });
      }
    }

    function spawnBatteryPickup() {
      state.pickups.push({
        x: canvas.width + 22,
        y: 60 + Math.random() * (canvas.height - 120),
        r: 10,
        amount: 26 + Math.random() * 20,
      });
    }

    function updateWeather() {
      if (state.running) {
        state.weatherCooldown -= 1;
        if (state.weatherCooldown <= 0) {
          spawnWeatherEvent();
          state.weatherCooldown = state.biome === "city"
            ? 210 + Math.floor(Math.random() * 180)
            : 170 + Math.floor(Math.random() * 160);
        }
      }

      for (let i = state.weatherEvents.length - 1; i >= 0; i -= 1) {
        const w = state.weatherEvents[i];

        if (w.type === "storm") {
          if (w.warn > 0) {
            w.warn -= 1;
          } else if (w.strike > 0) {
            w.strike -= 1;
            if (state.running && Math.abs(state.player.x - w.x) < w.width * 0.5) {
              endRun("Electrocuted");
            }
          } else {
            state.weatherEvents.splice(i, 1);
          }
        } else {
          w.x += w.drift;
          w.life -= 1;
          const dx = state.player.x - w.x;
          const dy = state.player.y - w.y;

          if (state.running && Math.hypot(dx, dy) < w.r + state.player.r) {
            state.battery = Math.max(0, state.battery - 0.36);
            if (state.battery <= 0) endRun("Toxic exposure");
          }

          if (w.life <= 0 || w.x + w.r < -20) {
            state.weatherEvents.splice(i, 1);
          }
        }
      }
    }

    function updatePickups() {
      if (state.running && state.biome === "metro") {
        state.pickupTimer -= 1;
        if (state.pickupTimer <= 0 && state.battery < 95) {
          spawnBatteryPickup();
          state.pickupTimer = 260 + Math.floor(Math.random() * 260);
        }
      }

      for (let i = state.pickups.length - 1; i >= 0; i -= 1) {
        const p = state.pickups[i];
        p.x -= 1.6;
        p.y += Math.sin((state.tick + i * 12) * 0.06) * 0.65;

        const dx = state.player.x - p.x;
        const dy = state.player.y - p.y;
        if (state.running && Math.hypot(dx, dy) < state.player.r + p.r) {
          state.battery = Math.min(100, state.battery + p.amount);
          burst(p.x, p.y, "#8effcf");
          state.pickups.splice(i, 1);
          continue;
        }

        if (p.x + p.r < -16) state.pickups.splice(i, 1);
      }
    }

    function updateShots() {
      for (let i = state.shots.length - 1; i >= 0; i -= 1) {
        const s = state.shots[i];
        s.x += s.vx;
        s.y += s.vy;

        const dx = state.player.x - s.x;
        const dy = state.player.y - s.y;
        if (state.running && Math.hypot(dx, dy) < state.player.r + s.r) {
          endRun("Sniped");
        }

        if (s.x < -20 || s.x > canvas.width + 20 || s.y < -20 || s.y > canvas.height + 20) {
          state.shots.splice(i, 1);
        }
      }
    }

    function updateEnemies() {
      const p = state.player;

      for (let i = state.enemies.length - 1; i >= 0; i -= 1) {
        const e = state.enemies[i];

        if (e.type === "drone") {
          e.x -= e.speed;
          e.y += Math.sin((state.tick + e.phase * 40) * 0.095) * 1.7;
        } else if (e.type === "mutant") {
          if (e.charge > 0) {
            e.charge -= 1;
            e.x -= e.speed * 2.3;
            e.y += e.chargeVy;
          } else {
            e.x -= e.speed * 0.85;
            const pull = Math.sign(p.y - e.y) * Math.min(1.6, Math.abs(p.y - e.y) * 0.03);
            e.y += pull;
            e.cooldown -= 1;
            if (e.cooldown <= 0 && e.x > p.x + 60) {
              e.charge = 28;
              e.chargeVy = (p.y - e.y) / 26;
              e.cooldown = 85 + Math.random() * 75;
            }
          }
        } else {
          if (e.x > canvas.width * 0.78) e.x -= 1.5;
          if (e.lock > 0) {
            e.lock -= 1;
            if (e.lock === 0) spawnShot(e);
          } else {
            e.fireCd -= 1;
            if (e.fireCd <= 0) {
              e.lock = 34;
              e.aimX = p.x;
              e.aimY = p.y;
              e.fireCd = 92 + Math.random() * 70;
            }
          }
        }

        e.y = Math.max(e.r, Math.min(canvas.height - e.r, e.y));

        const dx = p.x - e.x;
        const dy = p.y - e.y;
        if (state.running && Math.hypot(dx, dy) <= p.r + e.r) {
          const reason = e.type === "mutant" ? "Mauled" : (e.type === "turret" ? "Crushed" : "Shredded");
          endRun(reason);
        }

        if (e.x + e.r < -30) {
          state.enemies.splice(i, 1);
          burst(e.x, e.y, "#23f7ff");
        }
      }
    }

    function update() {
      if (state.running) {
        state.tick += 1;
        state.spawnTimer -= 1;
        if (state.biomeMode === "auto") {
          state.biomeTimer -= 1;

          if (state.biomeTimer <= 0) {
            switchBiome();
          }
        }

        if (state.spawnTimer <= 0) {
          spawnEnemy();
          state.spawnTimer = Math.max(12, 36 - Math.floor(state.score / 120));
        }

        const p = state.player;
        let moved = false;

        if (state.keys.has("arrowup") || state.keys.has("w")) {
          p.y -= p.speed;
          p.facingX = 0;
          p.facingY = -1;
          moved = true;
        }
        if (state.keys.has("arrowdown") || state.keys.has("s")) {
          p.y += p.speed;
          p.facingX = 0;
          p.facingY = 1;
          moved = true;
        }
        if (state.keys.has("arrowleft") || state.keys.has("a")) {
          p.x -= p.speed;
          p.facingX = -1;
          p.facingY = 0;
          moved = true;
        }
        if (state.keys.has("arrowright") || state.keys.has("d")) {
          p.x += p.speed;
          p.facingX = 1;
          p.facingY = 0;
          moved = true;
        }

        if (!moved) {
          p.facingX = 1;
          p.facingY = 0;
        }

        p.x = Math.max(p.r, Math.min(canvas.width - p.r, p.x));
        p.y = Math.max(p.r, Math.min(canvas.height - p.r, p.y));

        if (state.biome === "metro") {
          state.battery = Math.max(0, state.battery - 0.03);
          if (state.battery <= 0) endRun("Battery depleted");
        } else {
          state.battery = Math.min(100, state.battery + 0.045);
        }

        updateMission();
        updateWeather();
        updatePickups();
        updateEnemies();
        updateShots();

        if (state.tick % 5 === 0) {
          burst(p.x - 8, p.y, "#23f7ff");
        }

        state.score += 1;
      } else {
        updateWeather();
        updatePickups();
        updateShots();
      }

      for (let i = state.particles.length - 1; i >= 0; i -= 1) {
        const p = state.particles[i];
        p.x += p.vx;
        p.y += p.vy;
        p.vx *= 0.985;
        p.vy *= 0.985;
        p.life -= 1;
        if (p.life <= 0) state.particles.splice(i, 1);
      }

      updateHud();
    }

    function drawGrid() {
      ctx.save();
      ctx.globalAlpha = state.biome === "metro" ? 0.22 : 0.45;
      ctx.strokeStyle = getComputedStyle(document.documentElement).getPropertyValue("--grid").trim();
      ctx.lineWidth = 1;
      const gap = 34;
      const shift = (state.tick * 0.95) % gap;

      for (let x = -gap + shift; x < canvas.width + gap; x += gap) {
        ctx.beginPath();
        ctx.moveTo(x, 0);
        ctx.lineTo(x, canvas.height);
        ctx.stroke();
      }
      for (let y = 0; y < canvas.height; y += gap) {
        ctx.beginPath();
        ctx.moveTo(0, y);
        ctx.lineTo(canvas.width, y);
        ctx.stroke();
      }
      ctx.restore();
    }

    function drawGroundShadow(x, y, rx, ry) {
      ctx.save();
      const g = ctx.createRadialGradient(x, y, 2, x, y, rx);
      g.addColorStop(0, "rgba(0, 0, 0, 0.35)");
      g.addColorStop(1, "rgba(0, 0, 0, 0)");
      ctx.fillStyle = g;
      ctx.beginPath();
      ctx.ellipse(x, y, rx, ry, 0, 0, Math.PI * 2);
      ctx.fill();
      ctx.restore();
    }

    function drawPlayerModel(p, primary) {
      drawGroundShadow(p.x + 2, p.y + p.r + 8, p.r * 1.6, p.r * 0.62);
      ctx.save();
      ctx.translate(p.x, p.y);

      const bodyGrad = ctx.createRadialGradient(-p.r * 0.45, -p.r * 0.55, 2, 0, 0, p.r * 1.22);
      bodyGrad.addColorStop(0, "#f4fbff");
      bodyGrad.addColorStop(0.26, primary);
      bodyGrad.addColorStop(0.7, "#1d5f89");
      bodyGrad.addColorStop(1, "#0b263d");
      ctx.fillStyle = bodyGrad;
      ctx.shadowBlur = 22;
      ctx.shadowColor = primary;
      ctx.beginPath();
      ctx.ellipse(0, 0, p.r * 1.04, p.r * 0.95, 0, 0, Math.PI * 2);
      ctx.fill();

      ctx.shadowBlur = 0;
      ctx.fillStyle = "rgba(16, 38, 64, 0.65)";
      ctx.beginPath();
      ctx.ellipse(2, 5, p.r * 0.88, p.r * 0.56, 0, 0, Math.PI * 2);
      ctx.fill();

      const visorGrad = ctx.createLinearGradient(-p.r * 0.46, -p.r * 0.2, p.r * 0.56, -p.r * 0.34);
      visorGrad.addColorStop(0, "#f4ffff");
      visorGrad.addColorStop(1, "#8be7ff");
      ctx.fillStyle = visorGrad;
      ctx.beginPath();
      ctx.roundRect(-p.r * 0.56, -p.r * 0.43, p.r * 1.05, p.r * 0.4, p.r * 0.15);
      ctx.fill();

      ctx.strokeStyle = "rgba(255, 255, 255, 0.7)";
      ctx.lineWidth = 1.1;
      ctx.beginPath();
      ctx.arc(-p.r * 0.25, -p.r * 0.34, p.r * 0.25, 0, Math.PI * 1.6);
      ctx.stroke();

      ctx.restore();
    }

    function drawDroneModel(e, secondary) {
      drawGroundShadow(e.x + 2, e.y + e.r + 8, e.r * 1.45, e.r * 0.58);
      ctx.save();
      ctx.translate(e.x, e.y);
      ctx.shadowBlur = 18;
      ctx.shadowColor = secondary;

      const shell = ctx.createRadialGradient(-e.r * 0.35, -e.r * 0.45, 2, 0, 0, e.r * 1.24);
      shell.addColorStop(0, "#ffeefa");
      shell.addColorStop(0.32, secondary);
      shell.addColorStop(1, "#52103a");
      ctx.fillStyle = shell;
      ctx.beginPath();
      ctx.ellipse(0, 0, e.r * 1.05, e.r * 0.92, 0, 0, Math.PI * 2);
      ctx.fill();

      ctx.shadowBlur = 0;
      ctx.fillStyle = "#1b0f28cc";
      ctx.beginPath();
      ctx.ellipse(0, e.r * 0.15, e.r * 0.72, e.r * 0.42, 0, 0, Math.PI * 2);
      ctx.fill();

      ctx.strokeStyle = "rgba(255, 255, 255, 0.55)";
      ctx.lineWidth = 1;
      ctx.beginPath();
      ctx.moveTo(-e.r * 0.7, -e.r * 0.2);
      ctx.lineTo(e.r * 0.7, -e.r * 0.35);
      ctx.stroke();

      ctx.fillStyle = "#ffe5f3";
      ctx.beginPath();
      ctx.arc(-e.r * 0.2, -e.r * 0.4, e.r * 0.15, 0, Math.PI * 2);
      ctx.fill();
      ctx.restore();
    }

    function drawMutantModel(e) {
      drawGroundShadow(e.x + 3, e.y + e.r + 9, e.r * 1.5, e.r * 0.66);
      ctx.save();
      ctx.translate(e.x, e.y);
      ctx.shadowBlur = 16;
      ctx.shadowColor = "#ff7a40";

      const skin = ctx.createRadialGradient(-e.r * 0.25, -e.r * 0.45, 1, 0, 0, e.r * 1.3);
      skin.addColorStop(0, "#ffd8bf");
      skin.addColorStop(0.34, "#ff985f");
      skin.addColorStop(1, "#6b1f15");
      ctx.fillStyle = skin;
      ctx.beginPath();
      ctx.ellipse(0, 0, e.r * 1.08, e.r * 0.84, 0, 0, Math.PI * 2);
      ctx.fill();

      ctx.shadowBlur = 0;
      ctx.fillStyle = "#0000002e";
      ctx.beginPath();
      ctx.ellipse(e.r * 0.15, e.r * 0.18, e.r * 0.7, e.r * 0.35, 0, 0, Math.PI * 2);
      ctx.fill();

      ctx.fillStyle = "#2c1115";
      ctx.beginPath();
      ctx.ellipse(e.r * 0.28, -e.r * 0.18, e.r * 0.12, e.r * 0.1, 0, 0, Math.PI * 2);
      ctx.fill();

      ctx.fillStyle = "#fff3ea";
      ctx.beginPath();
      ctx.arc(-e.r * 0.16, -e.r * 0.34, e.r * 0.1, 0, Math.PI * 2);
      ctx.fill();
      ctx.restore();
    }

    function drawTurretModel(e) {
      drawGroundShadow(e.x + 3, e.y + e.r + 8, e.r * 1.5, e.r * 0.58);
      ctx.save();
      ctx.translate(e.x, e.y);
      ctx.shadowBlur = 14;
      ctx.shadowColor = "#ffb24f";

      const steel = ctx.createLinearGradient(-e.r, -e.r, e.r, e.r);
      steel.addColorStop(0, "#ffe3be");
      steel.addColorStop(0.4, "#ce8947");
      steel.addColorStop(1, "#543118");
      ctx.fillStyle = steel;
      ctx.beginPath();
      ctx.roundRect(-e.r, -e.r, e.r * 2, e.r * 2, e.r * 0.22);
      ctx.fill();

      ctx.shadowBlur = 0;
      ctx.fillStyle = "#251106cc";
      ctx.beginPath();
      ctx.roundRect(-e.r * 0.82, -e.r * 0.24, e.r * 1.64, e.r * 0.9, e.r * 0.18);
      ctx.fill();

      const turretHead = ctx.createRadialGradient(-e.r * 0.1, -e.r * 0.2, 2, 0, 0, e.r * 0.72);
      turretHead.addColorStop(0, "#fff4d7");
      turretHead.addColorStop(1, "#7d4a21");
      ctx.fillStyle = turretHead;
      ctx.beginPath();
      ctx.arc(0, -e.r * 0.05, e.r * 0.48, 0, Math.PI * 2);
      ctx.fill();

      ctx.fillStyle = "#311603";
      ctx.fillRect(e.r * 0.05, -e.r * 0.12, e.r * 0.62, e.r * 0.22);
      ctx.restore();
    }

    function draw() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);

      const darkTheme = document.documentElement.getAttribute("data-theme") === "dark";
      const inMetro = state.biome === "metro";
      const skyA = inMetro
        ? (darkTheme ? "#05070e" : "#9bafc4")
        : (darkTheme ? "#030718" : "#d6f3ff");
      const skyB = inMetro
        ? (darkTheme ? "#0d1118" : "#6d8798")
        : (darkTheme ? "#091427" : "#b6e7ff");

      const skyGrad = ctx.createLinearGradient(0, 0, 0, canvas.height);
      skyGrad.addColorStop(0, skyA);
      skyGrad.addColorStop(1, skyB);
      ctx.fillStyle = skyGrad;
      ctx.fillRect(0, 0, canvas.width, canvas.height);

      drawGrid();

      const p = state.player;
      const css = getComputedStyle(document.documentElement);
      const primary = css.getPropertyValue("--primary").trim();
      const secondary = css.getPropertyValue("--secondary").trim();

      drawPlayerModel(p, primary);

      for (const pickup of state.pickups) {
        drawGroundShadow(pickup.x, pickup.y + pickup.r + 5, pickup.r * 1.1, pickup.r * 0.45);
        ctx.save();
        const pick = ctx.createRadialGradient(
          pickup.x - pickup.r * 0.3,
          pickup.y - pickup.r * 0.45,
          1,
          pickup.x,
          pickup.y,
          pickup.r * 1.1
        );
        pick.addColorStop(0, "#f3fff9");
        pick.addColorStop(0.35, "#8effcf");
        pick.addColorStop(1, "#1d7f65");
        ctx.fillStyle = pick;
        ctx.shadowBlur = 14;
        ctx.shadowColor = "#8effcf";
        ctx.beginPath();
        ctx.arc(pickup.x, pickup.y, pickup.r, 0, Math.PI * 2);
        ctx.fill();
        ctx.fillStyle = "#ffffffcc";
        ctx.beginPath();
        ctx.arc(pickup.x - pickup.r * 0.32, pickup.y - pickup.r * 0.38, pickup.r * 0.2, 0, Math.PI * 2);
        ctx.fill();
        ctx.restore();
      }

      for (const e of state.enemies) {
        if (e.type === "drone") {
          drawDroneModel(e, secondary);
        } else if (e.type === "mutant") {
          drawMutantModel(e);
        } else {
          drawTurretModel(e);
          ctx.save();
          if (e.lock > 0) {
            ctx.strokeStyle = "#ffdf84";
            ctx.lineWidth = 1.5;
            ctx.beginPath();
            ctx.moveTo(e.x, e.y);
            ctx.lineTo(e.aimX, e.aimY);
            ctx.stroke();
          }
          ctx.restore();
        }
      }

      for (const s of state.shots) {
        drawGroundShadow(s.x + 1, s.y + s.r + 3, s.r * 1.3, s.r * 0.55);
        ctx.save();
        const shot = ctx.createRadialGradient(s.x - 1.5, s.y - 1.5, 1, s.x, s.y, s.r * 1.8);
        shot.addColorStop(0, "#fff7db");
        shot.addColorStop(0.4, "#ffc966");
        shot.addColorStop(1, "#8f4f13");
        ctx.fillStyle = shot;
        ctx.shadowBlur = 13;
        ctx.shadowColor = "#ffc966";
        ctx.beginPath();
        ctx.arc(s.x, s.y, s.r, 0, Math.PI * 2);
        ctx.fill();
        ctx.restore();
      }

      for (const w of state.weatherEvents) {
        if (w.type === "storm") {
          if (w.warn > 0) {
            ctx.fillStyle = "#f8df5945";
            ctx.fillRect(w.x - w.width * 0.5, 0, w.width, canvas.height);
          } else {
            ctx.fillStyle = "#ffe99195";
            ctx.fillRect(w.x - 3, 0, 6, canvas.height);
            ctx.strokeStyle = "#fff7d6";
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(w.x, 0);
            ctx.lineTo(w.x + Math.sin(state.tick * 0.5) * 8, canvas.height);
            ctx.stroke();
          }
        } else {
          const cloud = ctx.createRadialGradient(w.x, w.y, 10, w.x, w.y, w.r);
          cloud.addColorStop(0, "rgba(122, 228, 142, 0.34)");
          cloud.addColorStop(1, "rgba(122, 228, 142, 0)");
          ctx.fillStyle = cloud;
          ctx.beginPath();
          ctx.arc(w.x, w.y, w.r, 0, Math.PI * 2);
          ctx.fill();
        }
      }

      if (state.extraction) {
        const e = state.extraction;
        const pulse = 0.25 + 0.2 * Math.sin(state.tick * 0.12);
        ctx.save();
        ctx.strokeStyle = "#9be9ff";
        ctx.fillStyle = `rgba(126, 220, 255, ${0.12 + pulse})`;
        ctx.lineWidth = 2;
        ctx.fillRect(e.x, e.y, e.w, e.h);
        ctx.strokeRect(e.x, e.y, e.w, e.h);
        ctx.setLineDash([6, 4]);
        ctx.strokeRect(e.x - 8, e.y - 8, e.w + 16, e.h + 16);
        ctx.setLineDash([]);
        ctx.fillStyle = "#d9f6ff";
        ctx.font = "700 16px Chakra Petch, sans-serif";
        ctx.fillText("EXTRACTION", e.x + 10, e.y - 12);
        ctx.restore();
      }

      for (const part of state.particles) {
        ctx.save();
        ctx.globalAlpha = Math.max(0, part.life / 35);
        ctx.fillStyle = part.color;
        ctx.beginPath();
        ctx.arc(part.x, part.y, 2.2, 0, Math.PI * 2);
        ctx.fill();
        ctx.restore();
      }

      ctx.fillStyle = darkTheme ? "#d9f4ff" : "#12213f";
      ctx.font = "700 25px Orbitron, sans-serif";
      ctx.fillText(`Score ${Math.floor(state.score)}`, 18, 38);
      ctx.fillText(`Best ${state.best}`, 18, 72);
      ctx.font = "700 18px Chakra Petch, sans-serif";
      ctx.fillText(zoneName(), 18, 102);
      ctx.fillText(`Battery ${Math.round(state.battery)}%`, 18, 124);
      ctx.fillText(`Missions ${state.missionsCompleted}`, 18, 146);

      if (state.extraction) {
        const e = state.extraction;
        const barX = canvas.width - 250;
        const barY = 18;
        const barW = 220;
        const holdPct = e.hold / e.holdNeed;
        ctx.fillStyle = darkTheme ? "#0f1a2f" : "#c6dbf0";
        ctx.fillRect(barX, barY, barW, 14);
        ctx.fillStyle = "#8adfff";
        ctx.fillRect(barX, barY, barW * holdPct, 14);
        ctx.strokeStyle = darkTheme ? "#cbf4ff" : "#24508b";
        ctx.strokeRect(barX, barY, barW, 14);
        ctx.fillStyle = darkTheme ? "#dff8ff" : "#13254a";
        ctx.font = "700 14px Chakra Petch, sans-serif";
        ctx.fillText(`Extraction hold ${Math.floor(holdPct * 100)}%`, barX, barY + 30);
      }

      if (state.biome === "metro") {
        const lightStrength = 100 + state.battery * 3.2;
        const angle = Math.atan2(p.facingY, p.facingX);
        const spread = 0.72;

        ctx.save();
        ctx.fillStyle = darkTheme ? "rgba(0,0,0,0.72)" : "rgba(43,55,82,0.52)";
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        ctx.globalCompositeOperation = "destination-out";
        ctx.beginPath();
        ctx.moveTo(p.x, p.y);
        ctx.arc(p.x, p.y, lightStrength, angle - spread, angle + spread);
        ctx.closePath();
        ctx.fill();
        ctx.beginPath();
        ctx.arc(p.x, p.y, 68 + state.battery * 0.5, 0, Math.PI * 2);
        ctx.fill();
        ctx.restore();
      }

      if (!state.running) {
        ctx.fillStyle = darkTheme ? "#000000b8" : "#d8eeffbf";
        ctx.fillRect(0, 0, canvas.width, canvas.height);

        ctx.fillStyle = darkTheme ? "#fff" : "#112447";
        ctx.textAlign = "center";
        ctx.font = "800 56px Orbitron, sans-serif";
        ctx.fillText("Flatlined", canvas.width / 2, canvas.height / 2 - 24);
        ctx.font = "700 24px Chakra Petch, sans-serif";
        const reason = state.cause ? `Cause: ${state.cause}` : "Press R or Restart";
        ctx.fillText(reason, canvas.width / 2, canvas.height / 2 + 20);
        ctx.fillText("Press R or Restart", canvas.width / 2, canvas.height / 2 + 54);
        ctx.fillText(`Missions completed: ${state.missionsCompleted}`, canvas.width / 2, canvas.height / 2 + 88);
        ctx.textAlign = "left";
      }
    }

    function frame() {
      drawMatrix();
      update();
      draw();
      requestAnimationFrame(frame);
    }

    window.addEventListener("keydown", (event) => {
      const key = event.key.toLowerCase();
      state.keys.add(key);
      if (!state.running && key === "r") reset();
    });

    window.addEventListener("keyup", (event) => {
      state.keys.delete(event.key.toLowerCase());
    });

    restartButton.addEventListener("click", reset);

    themeSelect.addEventListener("change", (event) => {
      setTheme(event.target.value);
    });

    biomeSelect.addEventListener("change", (event) => {
      applyBiomeMode(event.target.value);
    });

    musicSelect.addEventListener("change", (event) => {
      const trackName = event.target.value;
      if (trackName === "off") {
        stopMusic();
      } else {
        startMusic(trackName);
      }
    });

    const savedTheme = localStorage.getItem(THEME_KEY);
    setTheme(savedTheme === "bright" ? "bright" : "dark");
    const savedBiomeMode = localStorage.getItem(BIOME_MODE_KEY);
    applyBiomeMode(savedBiomeMode === "city" || savedBiomeMode === "metro" ? savedBiomeMode : "auto");
    resizeMatrix();
    updateHud();
    window.addEventListener("resize", resizeMatrix);

    frame();
  </script>
</body>
</html>
