<!doctype html>
<html lang="en" data-theme="dark">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Neon Dodge 2077</title>
  <style>
    @import url("https://fonts.googleapis.com/css2?family=Chakra+Petch:wght@400;600;700&family=Orbitron:wght@500;700;800&display=swap");

    :root {
      --font-display: "Orbitron", sans-serif;
      --font-body: "Chakra Petch", sans-serif;
      --bg-0: #04070f;
      --bg-1: #071024;
      --bg-2: #0b1e3a;
      --panel: #0b1326c4;
      --ink: #d6f4ff;
      --muted: #8db4d0;
      --primary: #23f7ff;
      --secondary: #ff5b9f;
      --danger: #ff4f6c;
      --grid: #2ef8ff3d;
      --glow: #23f7ff88;
      --frame: #3ff9ff66;
    }

    html[data-theme="bright"] {
      --bg-0: #d5f7ff;
      --bg-1: #a7e5ff;
      --bg-2: #c2fff3;
      --panel: #f4fdffe6;
      --ink: #0f1d33;
      --muted: #365d75;
      --primary: #006dff;
      --secondary: #ff0077;
      --danger: #ff2f4b;
      --grid: #1566ff2a;
      --glow: #006dff5e;
      --frame: #1972ff5e;
    }

    * {
      box-sizing: border-box;
    }

    html,
    body {
      margin: 0;
      min-height: 100%;
      color: var(--ink);
      font-family: var(--font-body);
      overflow: hidden;
      background:
        radial-gradient(1300px 700px at 12% 6%, color-mix(in srgb, var(--primary) 20%, transparent), transparent 70%),
        radial-gradient(900px 500px at 90% 85%, color-mix(in srgb, var(--secondary) 24%, transparent), transparent 72%),
        linear-gradient(160deg, var(--bg-0), var(--bg-1) 52%, var(--bg-2));
    }

    body::before,
    body::after {
      content: "";
      position: fixed;
      inset: 0;
      pointer-events: none;
      z-index: 0;
    }

    body::before {
      background: repeating-linear-gradient(
        0deg,
        transparent,
        transparent 2px,
        color-mix(in srgb, var(--ink) 5%, transparent) 3px,
        transparent 4px
      );
      opacity: 0.32;
      animation: scanline 8s linear infinite;
    }

    body::after {
      background: radial-gradient(circle at 60% 30%, color-mix(in srgb, var(--primary) 16%, transparent), transparent 42%);
      mix-blend-mode: screen;
      animation: pulse 4.6s ease-in-out infinite;
    }

    .shell {
      width: min(96vw, 1060px);
      margin: clamp(10px, 2vw, 24px) auto;
      position: relative;
      z-index: 1;
      border: 1px solid var(--frame);
      border-radius: 16px;
      padding: clamp(10px, 1.7vw, 18px);
      background: linear-gradient(120deg, color-mix(in srgb, var(--panel) 88%, transparent), color-mix(in srgb, var(--panel) 72%, transparent));
      box-shadow: 0 24px 70px #0000005e, inset 0 0 28px color-mix(in srgb, var(--primary) 10%, transparent);
      backdrop-filter: blur(10px);
    }

    .hud {
      display: flex;
      gap: 12px;
      justify-content: space-between;
      align-items: center;
      flex-wrap: wrap;
      margin-bottom: 10px;
    }

    .title {
      font-family: var(--font-display);
      font-weight: 800;
      letter-spacing: 0.1em;
      text-transform: uppercase;
      font-size: clamp(1.1rem, 2.5vw, 1.9rem);
      position: relative;
      text-shadow: 0 0 22px var(--glow);
      animation: glitch 2.8s infinite;
    }

    .title::before,
    .title::after {
      content: attr(data-text);
      position: absolute;
      inset: 0;
      pointer-events: none;
      opacity: 0.6;
    }

    .title::before {
      color: color-mix(in srgb, var(--secondary) 80%, transparent);
      transform: translate(1.5px, -1px);
      clip-path: polygon(0 5%, 100% 0, 100% 36%, 0 40%);
    }

    .title::after {
      color: color-mix(in srgb, var(--primary) 88%, transparent);
      transform: translate(-1px, 1px);
      clip-path: polygon(0 62%, 100% 58%, 100% 100%, 0 100%);
    }

    .controls {
      display: flex;
      align-items: center;
      gap: 8px;
      flex-wrap: wrap;
      justify-content: flex-end;
    }

    .chip,
    select,
    button {
      border: 1px solid color-mix(in srgb, var(--primary) 55%, transparent);
      background: color-mix(in srgb, var(--bg-0) 55%, transparent);
      color: var(--ink);
      border-radius: 10px;
      padding: 0.42rem 0.62rem;
      font: 600 0.9rem var(--font-body);
    }

    select,
    button {
      cursor: pointer;
    }

    button:hover,
    select:hover {
      filter: brightness(1.08);
    }

    .chip {
      text-transform: uppercase;
      letter-spacing: 0.04em;
      font-size: 0.78rem;
      color: var(--muted);
    }

    .arena {
      position: relative;
    }

    canvas {
      width: 100%;
      aspect-ratio: 16 / 9;
      display: block;
      border: 1px solid var(--frame);
      border-radius: 14px;
      background: #020611;
      box-shadow: inset 0 0 45px #0ff2;
    }

    .status {
      margin-top: 10px;
      display: flex;
      justify-content: space-between;
      gap: 8px;
      color: var(--muted);
      font-size: 0.95rem;
      flex-wrap: wrap;
    }

    @keyframes glitch {
      0%, 85%, 100% { transform: translate(0, 0); }
      87% { transform: translate(1px, -1px); }
      89% { transform: translate(-2px, 1px); }
      91% { transform: translate(2px, 0); }
      93% { transform: translate(-1px, -1px); }
    }

    @keyframes scanline {
      from { transform: translateY(0); }
      to { transform: translateY(22px); }
    }

    @keyframes pulse {
      0%, 100% { opacity: 0.35; }
      50% { opacity: 0.6; }
    }

    @media (max-width: 720px) {
      .controls {
        justify-content: flex-start;
      }
    }
  </style>
</head>
<body>
  <main class="shell">
    <header class="hud">
      <div class="title" data-text="Neon Dodge 2077">Neon Dodge 2077</div>
      <div class="controls">
        <span class="chip">Theme</span>
        <select id="themeSelect" aria-label="Theme selector">
          <option value="dark">Dark</option>
          <option value="bright">Bright</option>
        </select>
        <span class="chip">Audio</span>
        <select id="musicSelect" aria-label="Music selector">
          <option value="off">Off</option>
          <option value="night_runner">Night Runner</option>
          <option value="chrome_heist">Chrome Heist</option>
          <option value="sunset_grid">Sunset Grid</option>
          <option value="overclock">Overclock</option>
        </select>
        <button id="restart">Restart</button>
      </div>
    </header>

    <section class="arena">
      <canvas id="game" width="960" height="540" aria-label="Neon Dodge game area"></canvas>
    </section>

    <footer class="status">
      <span id="help">Move with Arrow Keys / WASD, press R to restart.</span>
      <span id="audioState">Audio: Off</span>
    </footer>
  </main>

  <script>
    const canvas = document.getElementById("game");
    const ctx = canvas.getContext("2d");
    const restartButton = document.getElementById("restart");
    const themeSelect = document.getElementById("themeSelect");
    const musicSelect = document.getElementById("musicSelect");
    const audioState = document.getElementById("audioState");

    const THEME_KEY = "neon_dodge_theme";

    const state = {
      player: { x: 120, y: 270, r: 14, speed: 5.3 },
      enemies: [],
      particles: [],
      keys: new Set(),
      score: 0,
      best: Number(localStorage.getItem("neon_dodge_best") || 0),
      spawnTimer: 0,
      running: true,
      tick: 0,
    };

    let audioCtx;
    let masterGain;
    let sequenceTimer;
    let beatIndex = 0;
    let activeTrack = "off";

    const tracks = {
      night_runner: {
        bpm: 126,
        lead: [0, 7, 10, 7, 12, 7, 10, 7, 3, 7, 10, 7, 15, 10, 7, 3],
        bass: [0, 0, -5, -5, -3, -3, -5, -5],
      },
      chrome_heist: {
        bpm: 138,
        lead: [7, 12, 10, 7, 5, 10, 8, 5, 12, 15, 12, 8, 10, 12, 8, 5],
        bass: [0, -3, -5, -3, 0, -3, -7, -3],
      },
      sunset_grid: {
        bpm: 110,
        lead: [0, 4, 7, 11, 9, 7, 4, 2, 0, 2, 4, 7, 9, 11, 7, 4],
        bass: [0, -7, -5, -3, 0, -7, -10, -5],
      },
      overclock: {
        bpm: 148,
        lead: [0, 12, 7, 15, 10, 17, 12, 19, 7, 15, 10, 17, 3, 10, 7, 12],
        bass: [0, -3, -7, -10, -5, -8, -12, -7],
      },
    };

    function setTheme(theme) {
      document.documentElement.setAttribute("data-theme", theme);
      themeSelect.value = theme;
      localStorage.setItem(THEME_KEY, theme);
    }

    function freqFromSemitone(root, offset) {
      return root * Math.pow(2, offset / 12);
    }

    function ensureAudio() {
      if (!audioCtx) {
        audioCtx = new AudioContext();
        masterGain = audioCtx.createGain();
        masterGain.gain.value = 0.16;
        masterGain.connect(audioCtx.destination);
      }
      if (audioCtx.state === "suspended") {
        audioCtx.resume();
      }
    }

    function synthHit({ freq, time, dur, type, gain, detune = 0 }) {
      const osc = audioCtx.createOscillator();
      const env = audioCtx.createGain();

      osc.type = type;
      osc.frequency.setValueAtTime(freq, time);
      osc.detune.setValueAtTime(detune, time);

      env.gain.setValueAtTime(0.0001, time);
      env.gain.exponentialRampToValueAtTime(gain, time + 0.01);
      env.gain.exponentialRampToValueAtTime(0.0001, time + dur);

      osc.connect(env);
      env.connect(masterGain);
      osc.start(time);
      osc.stop(time + dur + 0.03);
    }

    function triggerKick(time) {
      const osc = audioCtx.createOscillator();
      const env = audioCtx.createGain();
      osc.type = "sine";
      osc.frequency.setValueAtTime(130, time);
      osc.frequency.exponentialRampToValueAtTime(45, time + 0.12);
      env.gain.setValueAtTime(0.0001, time);
      env.gain.exponentialRampToValueAtTime(0.2, time + 0.01);
      env.gain.exponentialRampToValueAtTime(0.0001, time + 0.18);
      osc.connect(env);
      env.connect(masterGain);
      osc.start(time);
      osc.stop(time + 0.2);
    }

    function stopMusic() {
      if (sequenceTimer) {
        clearInterval(sequenceTimer);
        sequenceTimer = null;
      }
      activeTrack = "off";
      audioState.textContent = "Audio: Off";
    }

    function startMusic(trackName) {
      if (trackName === "off") {
        stopMusic();
        return;
      }

      ensureAudio();
      if (sequenceTimer) clearInterval(sequenceTimer);

      const track = tracks[trackName];
      const stepMs = (60_000 / track.bpm) / 2;
      beatIndex = 0;
      activeTrack = trackName;
      audioState.textContent = `Audio: ${musicSelect.options[musicSelect.selectedIndex].text}`;

      sequenceTimer = setInterval(() => {
        if (!audioCtx) return;
        const now = audioCtx.currentTime;
        const leadStep = beatIndex % track.lead.length;
        const bassStep = beatIndex % track.bass.length;

        const leadNote = track.lead[leadStep];
        const bassNote = track.bass[bassStep];

        const leadFreq = freqFromSemitone(220, leadNote);
        const bassFreq = freqFromSemitone(110, bassNote);

        synthHit({ freq: leadFreq, time: now, dur: 0.16, type: "square", gain: 0.035 });
        synthHit({ freq: leadFreq * 2, time: now, dur: 0.08, type: "triangle", gain: 0.012, detune: 4 });

        if (beatIndex % 2 === 0) {
          synthHit({ freq: bassFreq, time: now, dur: 0.22, type: "sawtooth", gain: 0.028 });
        }

        if (beatIndex % 4 === 0) {
          triggerKick(now);
        }

        beatIndex += 1;
      }, stepMs);
    }

    function burst(x, y, color) {
      for (let i = 0; i < 9; i += 1) {
        const angle = Math.random() * Math.PI * 2;
        const speed = 1.2 + Math.random() * 3.1;
        state.particles.push({
          x,
          y,
          vx: Math.cos(angle) * speed,
          vy: Math.sin(angle) * speed,
          life: 26 + Math.random() * 24,
          color,
        });
      }
    }

    function reset() {
      state.player.x = 120;
      state.player.y = canvas.height / 2;
      state.enemies = [];
      state.particles = [];
      state.score = 0;
      state.spawnTimer = 0;
      state.running = true;
      state.tick = 0;
    }

    function spawnEnemy() {
      const size = 10 + Math.random() * 24;
      const speed = 3.1 + Math.random() * 4 + state.score / 330;
      const laneWobble = Math.sin(state.tick * 0.025 + Math.random() * Math.PI) * 42;
      state.enemies.push({
        x: canvas.width + size,
        y: size + Math.random() * (canvas.height - size * 2) + laneWobble,
        r: size,
        speed,
      });
    }

    function update() {
      if (state.running) {
        state.tick += 1;
        state.spawnTimer -= 1;

        if (state.spawnTimer <= 0) {
          spawnEnemy();
          state.spawnTimer = Math.max(14, 42 - Math.floor(state.score / 90));
        }

        const p = state.player;
        if (state.keys.has("arrowup") || state.keys.has("w")) p.y -= p.speed;
        if (state.keys.has("arrowdown") || state.keys.has("s")) p.y += p.speed;
        if (state.keys.has("arrowleft") || state.keys.has("a")) p.x -= p.speed;
        if (state.keys.has("arrowright") || state.keys.has("d")) p.x += p.speed;

        p.x = Math.max(p.r, Math.min(canvas.width - p.r, p.x));
        p.y = Math.max(p.r, Math.min(canvas.height - p.r, p.y));

        for (let i = state.enemies.length - 1; i >= 0; i -= 1) {
          const e = state.enemies[i];
          e.x -= e.speed;
          e.y += Math.sin((state.tick + i * 12) * 0.03) * 0.6;

          const dx = p.x - e.x;
          const dy = p.y - e.y;
          const hit = Math.hypot(dx, dy) <= p.r + e.r;

          if (hit) {
            burst(p.x, p.y, "#ff5b9f");
            state.running = false;
            state.best = Math.max(state.best, Math.floor(state.score));
            localStorage.setItem("neon_dodge_best", String(state.best));
            break;
          }

          if (e.x + e.r < -8) {
            state.enemies.splice(i, 1);
            burst(e.x, e.y, "#23f7ff");
          }
        }

        if (state.tick % 5 === 0) {
          burst(p.x - 8, p.y, "#23f7ff");
        }

        state.score += 1;
      }

      for (let i = state.particles.length - 1; i >= 0; i -= 1) {
        const p = state.particles[i];
        p.x += p.vx;
        p.y += p.vy;
        p.vx *= 0.985;
        p.vy *= 0.985;
        p.life -= 1;
        if (p.life <= 0) state.particles.splice(i, 1);
      }
    }

    function drawGrid() {
      ctx.save();
      ctx.globalAlpha = 0.45;
      ctx.strokeStyle = getComputedStyle(document.documentElement).getPropertyValue("--grid").trim();
      ctx.lineWidth = 1;
      const gap = 34;
      const shift = (state.tick * 0.95) % gap;

      for (let x = -gap + shift; x < canvas.width + gap; x += gap) {
        ctx.beginPath();
        ctx.moveTo(x, 0);
        ctx.lineTo(x, canvas.height);
        ctx.stroke();
      }
      for (let y = 0; y < canvas.height; y += gap) {
        ctx.beginPath();
        ctx.moveTo(0, y);
        ctx.lineTo(canvas.width, y);
        ctx.stroke();
      }
      ctx.restore();
    }

    function draw() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);

      const darkTheme = document.documentElement.getAttribute("data-theme") === "dark";
      const skyA = darkTheme ? "#030718" : "#d6f3ff";
      const skyB = darkTheme ? "#091427" : "#b6e7ff";
      const skyGrad = ctx.createLinearGradient(0, 0, 0, canvas.height);
      skyGrad.addColorStop(0, skyA);
      skyGrad.addColorStop(1, skyB);
      ctx.fillStyle = skyGrad;
      ctx.fillRect(0, 0, canvas.width, canvas.height);

      drawGrid();

      const p = state.player;
      const primary = getComputedStyle(document.documentElement).getPropertyValue("--primary").trim();
      const secondary = getComputedStyle(document.documentElement).getPropertyValue("--secondary").trim();

      ctx.save();
      ctx.shadowBlur = 26;
      ctx.shadowColor = primary;
      ctx.fillStyle = primary;
      ctx.beginPath();
      ctx.arc(p.x, p.y, p.r, 0, Math.PI * 2);
      ctx.fill();
      ctx.restore();

      for (const e of state.enemies) {
        ctx.save();
        ctx.fillStyle = secondary;
        ctx.shadowBlur = 24;
        ctx.shadowColor = secondary;
        ctx.beginPath();
        ctx.arc(e.x, e.y, e.r, 0, Math.PI * 2);
        ctx.fill();
        ctx.restore();
      }

      for (const part of state.particles) {
        ctx.save();
        ctx.globalAlpha = Math.max(0, part.life / 35);
        ctx.fillStyle = part.color;
        ctx.beginPath();
        ctx.arc(part.x, part.y, 2.2, 0, Math.PI * 2);
        ctx.fill();
        ctx.restore();
      }

      ctx.fillStyle = darkTheme ? "#d9f4ff" : "#12213f";
      ctx.font = "700 25px Orbitron, sans-serif";
      ctx.fillText(`Score ${Math.floor(state.score)}`, 18, 38);
      ctx.fillText(`Best ${state.best}`, 18, 72);

      if (!state.running) {
        ctx.fillStyle = darkTheme ? "#000000b8" : "#d8eeffbf";
        ctx.fillRect(0, 0, canvas.width, canvas.height);

        ctx.fillStyle = darkTheme ? "#fff" : "#112447";
        ctx.textAlign = "center";
        ctx.font = "800 56px Orbitron, sans-serif";
        ctx.fillText("Flatlined", canvas.width / 2, canvas.height / 2 - 24);
        ctx.font = "700 24px Chakra Petch, sans-serif";
        ctx.fillText("Press R or Restart", canvas.width / 2, canvas.height / 2 + 22);
        ctx.textAlign = "left";
      }
    }

    function frame() {
      update();
      draw();
      requestAnimationFrame(frame);
    }

    window.addEventListener("keydown", (event) => {
      const key = event.key.toLowerCase();
      state.keys.add(key);
      if (!state.running && key === "r") reset();
    });

    window.addEventListener("keyup", (event) => {
      state.keys.delete(event.key.toLowerCase());
    });

    restartButton.addEventListener("click", () => {
      reset();
    });

    themeSelect.addEventListener("change", (event) => {
      setTheme(event.target.value);
    });

    musicSelect.addEventListener("change", (event) => {
      const trackName = event.target.value;
      if (trackName === "off") {
        stopMusic();
      } else {
        startMusic(trackName);
      }
    });

    const savedTheme = localStorage.getItem(THEME_KEY);
    setTheme(savedTheme === "bright" ? "bright" : "dark");

    frame();
  </script>
</body>
</html>
