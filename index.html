<!doctype html>
<html lang="en" data-theme="dark">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Neon Dodge 2077</title>
  <style>
    @import url("https://fonts.googleapis.com/css2?family=Chakra+Petch:wght@400;600;700&family=Orbitron:wght@500;700;800&display=swap");

    :root {
      --font-display: "Orbitron", sans-serif;
      --font-body: "Chakra Petch", sans-serif;
      --bg-0: #04070f;
      --bg-1: #071024;
      --bg-2: #0b1e3a;
      --panel: #0b1326c4;
      --ink: #d6f4ff;
      --muted: #8db4d0;
      --primary: #23f7ff;
      --secondary: #ff5b9f;
      --danger: #ff4f6c;
      --grid: #2ef8ff3d;
      --glow: #23f7ff88;
      --frame: #3ff9ff66;
    }

    html[data-theme="bright"] {
      --bg-0: #d5f7ff;
      --bg-1: #a7e5ff;
      --bg-2: #c2fff3;
      --panel: #f4fdffe6;
      --ink: #0f1d33;
      --muted: #365d75;
      --primary: #006dff;
      --secondary: #ff0077;
      --danger: #ff2f4b;
      --grid: #1566ff2a;
      --glow: #006dff5e;
      --frame: #1972ff5e;
    }

    * {
      box-sizing: border-box;
    }

    html,
    body {
      margin: 0;
      min-height: 100%;
      color: var(--ink);
      font-family: var(--font-body);
      overflow: hidden;
      background:
        radial-gradient(1300px 700px at 12% 6%, color-mix(in srgb, var(--primary) 20%, transparent), transparent 70%),
        radial-gradient(900px 500px at 90% 85%, color-mix(in srgb, var(--secondary) 24%, transparent), transparent 72%),
        linear-gradient(160deg, var(--bg-0), var(--bg-1) 52%, var(--bg-2));
    }

    body::before,
    body::after {
      content: "";
      position: fixed;
      inset: 0;
      pointer-events: none;
      z-index: 1;
    }

    body::before {
      background: repeating-linear-gradient(
        0deg,
        transparent,
        transparent 2px,
        color-mix(in srgb, var(--ink) 5%, transparent) 3px,
        transparent 4px
      );
      opacity: 0.32;
      animation: scanline 8s linear infinite;
    }

    body::after {
      background: radial-gradient(circle at 60% 30%, color-mix(in srgb, var(--primary) 16%, transparent), transparent 42%);
      mix-blend-mode: screen;
      animation: pulse 4.6s ease-in-out infinite;
    }

    #matrixRain {
      position: fixed;
      inset: 0;
      width: 100vw;
      height: 100vh;
      z-index: 0;
      pointer-events: none;
      opacity: 0.62;
    }

    .shell {
      width: min(96vw, 1060px);
      margin: clamp(10px, 2vw, 24px) auto;
      position: relative;
      z-index: 2;
      border: 1px solid var(--frame);
      border-radius: 16px;
      padding: clamp(10px, 1.7vw, 18px);
      background: linear-gradient(120deg, color-mix(in srgb, var(--panel) 88%, transparent), color-mix(in srgb, var(--panel) 72%, transparent));
      box-shadow: 0 24px 70px #0000005e, inset 0 0 28px color-mix(in srgb, var(--primary) 10%, transparent);
      backdrop-filter: blur(10px);
    }

    .hud {
      display: flex;
      gap: 12px;
      justify-content: space-between;
      align-items: center;
      flex-wrap: wrap;
      margin-bottom: 10px;
    }

    .title {
      font-family: var(--font-display);
      font-weight: 800;
      letter-spacing: 0.1em;
      text-transform: uppercase;
      font-size: clamp(1.1rem, 2.5vw, 1.9rem);
      position: relative;
      text-shadow: 0 0 22px var(--glow);
      animation: glitch 2.8s infinite;
    }

    .title::before,
    .title::after {
      content: attr(data-text);
      position: absolute;
      inset: 0;
      pointer-events: none;
      opacity: 0.6;
    }

    .title::before {
      color: color-mix(in srgb, var(--secondary) 80%, transparent);
      transform: translate(1.5px, -1px);
      clip-path: polygon(0 5%, 100% 0, 100% 36%, 0 40%);
    }

    .title::after {
      color: color-mix(in srgb, var(--primary) 88%, transparent);
      transform: translate(-1px, 1px);
      clip-path: polygon(0 62%, 100% 58%, 100% 100%, 0 100%);
    }

    .controls {
      display: flex;
      align-items: center;
      gap: 8px;
      flex-wrap: wrap;
      justify-content: flex-end;
    }

    .chip,
    select,
    button {
      border: 1px solid color-mix(in srgb, var(--primary) 55%, transparent);
      background: color-mix(in srgb, var(--bg-0) 55%, transparent);
      color: var(--ink);
      border-radius: 10px;
      padding: 0.42rem 0.62rem;
      font: 600 0.9rem var(--font-body);
    }

    select,
    button {
      cursor: pointer;
    }

    button:hover,
    select:hover {
      filter: brightness(1.08);
    }

    .chip {
      text-transform: uppercase;
      letter-spacing: 0.04em;
      font-size: 0.78rem;
      color: var(--muted);
    }

    .arena {
      position: relative;
    }

    canvas {
      width: 100%;
      aspect-ratio: 16 / 9;
      display: block;
      border: 1px solid var(--frame);
      border-radius: 14px;
      background: #020611;
      box-shadow: inset 0 0 45px #0ff2;
    }

    .status {
      margin-top: 10px;
      display: flex;
      justify-content: space-between;
      gap: 8px;
      color: var(--muted);
      font-size: 0.95rem;
      flex-wrap: wrap;
    }

    .overlay-btn {
      border: 1px solid color-mix(in srgb, var(--secondary) 55%, transparent);
      background: color-mix(in srgb, var(--bg-0) 62%, transparent);
      color: var(--ink);
      border-radius: 10px;
      padding: 0.42rem 0.62rem;
      font: 600 0.85rem var(--font-body);
      cursor: pointer;
    }

    .settings-panel {
      position: fixed;
      right: 16px;
      top: 16px;
      z-index: 5;
      width: min(92vw, 320px);
      background: color-mix(in srgb, var(--panel) 90%, transparent);
      border: 1px solid var(--frame);
      border-radius: 12px;
      padding: 10px;
      display: none;
      backdrop-filter: blur(10px);
      box-shadow: 0 18px 35px #0000004d;
    }

    .settings-panel.open {
      display: block;
    }

    .settings-grid {
      display: grid;
      grid-template-columns: 1fr auto;
      gap: 8px;
      align-items: center;
      font-size: 0.9rem;
    }

    .settings-panel input[type="range"] {
      width: 120px;
    }

    .touch-ui {
      position: fixed;
      inset: auto 0 8px 0;
      z-index: 4;
      display: none;
      justify-content: space-between;
      padding: 0 10px;
      pointer-events: none;
    }

    .touch-cluster {
      display: grid;
      grid-template-columns: repeat(3, 52px);
      grid-template-rows: repeat(2, 52px);
      gap: 6px;
      pointer-events: auto;
    }

    .touch-btn {
      border: 1px solid var(--frame);
      background: color-mix(in srgb, var(--bg-0) 72%, transparent);
      color: var(--ink);
      border-radius: 10px;
      font: 700 0.9rem var(--font-body);
    }

    .touch-fire {
      width: 68px;
      height: 68px;
      border-radius: 50%;
      align-self: end;
      margin-right: 10px;
    }

    .touch-dash {
      width: 56px;
      height: 56px;
      border-radius: 50%;
      align-self: end;
      margin-right: 10px;
      margin-bottom: 74px;
    }

    @keyframes glitch {
      0%, 85%, 100% { transform: translate(0, 0); }
      87% { transform: translate(1px, -1px); }
      89% { transform: translate(-2px, 1px); }
      91% { transform: translate(2px, 0); }
      93% { transform: translate(-1px, -1px); }
    }

    @keyframes scanline {
      from { transform: translateY(0); }
      to { transform: translateY(22px); }
    }

    @keyframes pulse {
      0%, 100% { opacity: 0.35; }
      50% { opacity: 0.6; }
    }

    @media (max-width: 720px) {
      .controls {
        justify-content: flex-start;
      }
      .touch-ui {
        display: flex;
      }
    }
  </style>
</head>
<body>
  <canvas id="matrixRain" aria-hidden="true"></canvas>

  <main class="shell">
    <header class="hud">
      <div class="title" data-text="Neon Dodge 2077">Neon Dodge 2077</div>
      <div class="controls">
        <span class="chip">Theme</span>
        <select id="themeSelect" aria-label="Theme selector">
          <option value="dark">Dark</option>
          <option value="bright">Bright</option>
        </select>
        <span class="chip">Zone</span>
        <select id="biomeSelect" aria-label="Zone selector">
          <option value="auto">Auto</option>
          <option value="city">Neon City</option>
          <option value="metro">Metro Tunnel</option>
        </select>
        <span class="chip">Audio</span>
        <select id="musicSelect" aria-label="Music selector">
          <option value="off">Off</option>
          <option value="night_runner">Night Runner</option>
          <option value="chrome_heist">Chrome Heist</option>
          <option value="sunset_grid">Sunset Grid</option>
          <option value="overclock">Overclock</option>
        </select>
        <button id="settingsBtn" class="overlay-btn">Settings</button>
        <button id="restart">Restart</button>
      </div>
    </header>

    <section class="arena">
      <canvas id="game" width="960" height="540" aria-label="Neon Dodge game area"></canvas>
    </section>

    <footer class="status">
      <span id="help">Move: WASD/Arrows, Fire: Mouse or Space/F, Restart: R.</span>
      <span id="missionState">Objective: Sync signal</span>
      <span id="biomeState">Zone: Neon City</span>
      <span id="batteryState">Battery: 100%</span>
      <span id="weaponState">Weapon: 12/12</span>
      <span id="audioState">Audio: Off</span>
    </footer>
  </main>

  <aside id="settingsPanel" class="settings-panel" aria-label="Settings panel">
    <div class="settings-grid">
      <label for="sfxVolume">SFX Volume</label>
      <input id="sfxVolume" type="range" min="0" max="100" value="70" />
      <label for="musicVolume">Music Volume</label>
      <input id="musicVolume" type="range" min="0" max="100" value="50" />
      <label for="qualityMode">Quality</label>
      <select id="qualityMode">
        <option value="high">High</option>
        <option value="low">Low</option>
      </select>
      <label for="colorblindMode">Colorblind</label>
      <select id="colorblindMode">
        <option value="off">Off</option>
        <option value="on">On</option>
      </select>
      <label for="fireKeyInput">Fire Key</label>
      <input id="fireKeyInput" type="text" value="f" maxlength="1" />
      <label for="dashKeyInput">Dash Key</label>
      <input id="dashKeyInput" type="text" value="shift" maxlength="5" />
    </div>
  </aside>

  <div class="touch-ui" id="touchUi" aria-hidden="true">
    <div class="touch-cluster">
      <button class="touch-btn" data-key="arrowup" style="grid-column:2;grid-row:1;">U</button>
      <button class="touch-btn" data-key="arrowleft" style="grid-column:1;grid-row:2;">L</button>
      <button class="touch-btn" data-key="arrowdown" style="grid-column:2;grid-row:2;">D</button>
      <button class="touch-btn" data-key="arrowright" style="grid-column:3;grid-row:2;">R</button>
    </div>
    <button class="touch-btn touch-dash" id="touchDash">Dash</button>
    <button class="touch-btn touch-fire" id="touchFire">Fire</button>
  </div>

  <script>
    const matrixCanvas = document.getElementById("matrixRain");
    const matrixCtx = matrixCanvas.getContext("2d");
    const canvas = document.getElementById("game");
    const ctx = canvas.getContext("2d");
    const restartButton = document.getElementById("restart");
    const settingsBtn = document.getElementById("settingsBtn");
    const settingsPanel = document.getElementById("settingsPanel");
    const themeSelect = document.getElementById("themeSelect");
    const biomeSelect = document.getElementById("biomeSelect");
    const musicSelect = document.getElementById("musicSelect");
    const sfxVolume = document.getElementById("sfxVolume");
    const musicVolume = document.getElementById("musicVolume");
    const qualityMode = document.getElementById("qualityMode");
    const colorblindMode = document.getElementById("colorblindMode");
    const fireKeyInput = document.getElementById("fireKeyInput");
    const dashKeyInput = document.getElementById("dashKeyInput");
    const touchUi = document.getElementById("touchUi");
    const touchFire = document.getElementById("touchFire");
    const touchDash = document.getElementById("touchDash");
    const missionState = document.getElementById("missionState");
    const biomeState = document.getElementById("biomeState");
    const batteryState = document.getElementById("batteryState");
    const weaponState = document.getElementById("weaponState");
    const audioState = document.getElementById("audioState");

    const THEME_KEY = "neon_dodge_theme";
    const BIOME_MODE_KEY = "neon_dodge_biome_mode";
    const SETTINGS_KEY = "neon_dodge_settings";
    const SCRAP_KEY = "neon_dodge_scrap";
    const UPGRADE_KEY = "neon_dodge_upgrades";

    const state = {
      player: { x: 120, y: 270, r: 14, speed: 5.3, facingX: 1, facingY: 0, aimX: null, aimY: null },
      enemies: [],
      playerShots: [],
      particles: [],
      pickups: [],
      shots: [],
      weatherEvents: [],
      keys: new Set(),
      score: 0,
      best: Number(localStorage.getItem("neon_dodge_best") || 0),
      spawnTimer: 0,
      pickupTimer: 260,
      weatherCooldown: 320,
      running: true,
      tick: 0,
      biome: "city",
      biomeMode: "auto",
      biomeTimer: 1600,
      battery: 100,
      missionsCompleted: 0,
      missionKind: "sync",
      missionCounter: 0,
      surviveTicks: 0,
      killsThisMission: 0,
      missionPhase: "travel",
      missionProgress: 0,
      missionTarget: 700,
      extraction: null,
      bossActive: false,
      difficulty: 1,
      firing: false,
      dash: {
        stamina: 100,
        staminaMax: 100,
        cooldown: 0,
        cooldownMax: 36,
      },
      weapon: {
        type: "pistol",
        ammo: 12,
        ammoMax: 12,
        reloadTimer: 0,
        reloadDuration: 96,
        fireCooldown: 0,
        fireRate: 8,
        damage: 1,
      },
      upgrades: { damage: 0, maxHealth: 0, dash: 0 },
      health: 100,
      healthMax: 100,
      scrap: Number(localStorage.getItem(SCRAP_KEY) || 0),
      settings: {
        sfxVolume: 0.7,
        musicVolume: 0.5,
        quality: "high",
        colorblind: "off",
        fireKey: "f",
        dashKey: "shift",
      },
      hitFlash: 0,
      screenShake: 0,
      playerIframes: 0,
      lastHitAngle: 0,
      cause: "",
    };

    let audioCtx;
    let masterGain;
    let sfxGain;
    let sequenceTimer;
    let beatIndex = 0;

    const matrix = {
      fontSize: 16,
      chars: "01@#$%&*+-<>[]{}ABCDEFGHIJKLMNOPQRSTUVWXYZ".split(""),
      drops: [],
    };

    const tracks = {
      night_runner: {
        bpm: 126,
        lead: [0, 7, 10, 7, 12, 7, 10, 7, 3, 7, 10, 7, 15, 10, 7, 3],
        bass: [0, 0, -5, -5, -3, -3, -5, -5],
      },
      chrome_heist: {
        bpm: 138,
        lead: [7, 12, 10, 7, 5, 10, 8, 5, 12, 15, 12, 8, 10, 12, 8, 5],
        bass: [0, -3, -5, -3, 0, -3, -7, -3],
      },
      sunset_grid: {
        bpm: 110,
        lead: [0, 4, 7, 11, 9, 7, 4, 2, 0, 2, 4, 7, 9, 11, 7, 4],
        bass: [0, -7, -5, -3, 0, -7, -10, -5],
      },
      overclock: {
        bpm: 148,
        lead: [0, 12, 7, 15, 10, 17, 12, 19, 7, 15, 10, 17, 3, 10, 7, 12],
        bass: [0, -3, -7, -10, -5, -8, -12, -7],
      },
    };

    const weaponProfiles = {
      pistol: { ammoMax: 12, fireRate: 8, damage: 1.15, reloadDuration: 78, spread: 0.018, speed: 10.5 },
      smg: { ammoMax: 26, fireRate: 4, damage: 0.62, reloadDuration: 92, spread: 0.06, speed: 10.7 },
      shotgun: { ammoMax: 7, fireRate: 17, damage: 0.72, reloadDuration: 112, spread: 0.22, speed: 9.4, pellets: 5 },
    };

    function applyWeaponProfile(type) {
      const p = weaponProfiles[type];
      state.weapon.type = type;
      state.weapon.ammoMax = p.ammoMax;
      state.weapon.ammo = Math.min(state.weapon.ammo, p.ammoMax);
      state.weapon.fireRate = p.fireRate;
      state.weapon.reloadDuration = p.reloadDuration;
      state.weapon.damage = p.damage + state.upgrades.damage * 0.16;
      if (state.weapon.ammo <= 0) state.weapon.ammo = p.ammoMax;
    }

    function cycleWeapon() {
      const order = ["pistol", "smg", "shotgun"];
      const idx = order.indexOf(state.weapon.type);
      applyWeaponProfile(order[(idx + 1) % order.length]);
      playSfx("swap");
    }

    function saveSettings() {
      localStorage.setItem(SETTINGS_KEY, JSON.stringify(state.settings));
      localStorage.setItem(UPGRADE_KEY, JSON.stringify(state.upgrades));
      localStorage.setItem(SCRAP_KEY, String(state.scrap));
    }

    function loadSettings() {
      try {
        const s = JSON.parse(localStorage.getItem(SETTINGS_KEY) || "{}");
        const u = JSON.parse(localStorage.getItem(UPGRADE_KEY) || "{}");
        state.settings = { ...state.settings, ...s };
        state.upgrades = { ...state.upgrades, ...u };
      } catch (_) {}
      sfxVolume.value = String(Math.round(state.settings.sfxVolume * 100));
      musicVolume.value = String(Math.round(state.settings.musicVolume * 100));
      qualityMode.value = state.settings.quality;
      colorblindMode.value = state.settings.colorblind;
      fireKeyInput.value = state.settings.fireKey;
      dashKeyInput.value = state.settings.dashKey;
    }

    function applySettingsToRuntime() {
      document.documentElement.style.filter = state.settings.colorblind === "on" ? "saturate(0.78) contrast(1.08)" : "";
      if (masterGain) masterGain.gain.value = 0.16 * state.settings.musicVolume;
      if (sfxGain) sfxGain.gain.value = state.settings.sfxVolume;
    }

    function isFireKey(key) {
      return key === state.settings.fireKey || key === " ";
    }

    function isDashKey(key) {
      return key === state.settings.dashKey;
    }

    function upgradeCost(type) {
      const level = state.upgrades[type];
      return 30 + level * 28;
    }

    function tryUpgrade(type) {
      const cost = upgradeCost(type);
      if (state.scrap < cost) return false;
      state.scrap -= cost;
      state.upgrades[type] += 1;
      if (type === "maxHealth") {
        state.healthMax = 100 + state.upgrades.maxHealth * 12;
        state.health = Math.min(state.healthMax, state.health + 12);
      }
      if (type === "dash") {
        state.dash.staminaMax = 100 + state.upgrades.dash * 14;
      }
      applyWeaponProfile(state.weapon.type);
      saveSettings();
      playSfx("upgrade");
      return true;
    }

    function setTheme(theme) {
      document.documentElement.setAttribute("data-theme", theme);
      themeSelect.value = theme;
      localStorage.setItem(THEME_KEY, theme);
    }

    function applyBiomeMode(mode) {
      state.biomeMode = mode;
      biomeSelect.value = mode;
      localStorage.setItem(BIOME_MODE_KEY, mode);

      if (mode === "city") {
        state.biome = "city";
      } else if (mode === "metro") {
        state.biome = "metro";
      } else {
        state.biomeTimer = 900;
      }
    }

    function zoneName() {
      return state.biome === "city" ? "Neon City" : "Metro Tunnel";
    }

    function updateHud() {
      if (state.missionPhase === "travel") {
        if (state.missionKind === "sync") {
          const pct = Math.min(100, Math.floor((state.missionProgress / state.missionTarget) * 100));
          missionState.textContent = `Objective: Sync signal ${pct}%`;
        } else if (state.missionKind === "hunt") {
          missionState.textContent = `Objective: Eliminate ${state.missionCounter}/${state.missionTarget}`;
        } else {
          missionState.textContent = `Objective: Survive ${Math.ceil((state.missionTarget - state.missionCounter) / 60)}s`;
        }
      } else {
        const holdPct = state.extraction
          ? Math.min(100, Math.floor((state.extraction.hold / state.extraction.holdNeed) * 100))
          : 0;
        const timer = state.extraction ? Math.ceil(state.extraction.timer / 60) : 0;
        missionState.textContent = `Objective: Reach extraction ${holdPct}% (${timer}s)`;
      }
      if (state.bossActive) {
        missionState.textContent = `Objective: BOSS ENGAGEMENT`;
      }
      biomeState.textContent = `Zone: ${zoneName()}`;
      batteryState.textContent = `Battery: ${Math.round(state.battery)}%`;
      batteryState.style.color = state.battery < 22 ? "var(--danger)" : "var(--muted)";
      if (state.weapon.reloadTimer > 0) {
        weaponState.textContent = `Weapon: ${state.weapon.type.toUpperCase()} Reloading ${Math.ceil(state.weapon.reloadTimer / 60)}s | HP ${Math.round(state.health)} | Dash ${Math.round(state.dash.stamina)}`;
        weaponState.style.color = "var(--danger)";
      } else {
        weaponState.textContent = `Weapon: ${state.weapon.type.toUpperCase()} ${state.weapon.ammo}/${state.weapon.ammoMax} | HP ${Math.round(state.health)} | Dash ${Math.round(state.dash.stamina)} | Scrap ${state.scrap}`;
        weaponState.style.color = state.weapon.ammo <= 3 ? "var(--danger)" : "var(--muted)";
      }
    }

    function resizeMatrix() {
      matrixCanvas.width = window.innerWidth;
      matrixCanvas.height = window.innerHeight;
      const cols = Math.ceil(matrixCanvas.width / matrix.fontSize);
      matrix.drops = Array.from({ length: cols }, () => Math.random() * matrixCanvas.height / matrix.fontSize);
      matrixCtx.font = `${matrix.fontSize}px Chakra Petch, monospace`;
    }

    function drawMatrix() {
      const darkTheme = document.documentElement.getAttribute("data-theme") === "dark";
      const fade = darkTheme ? "rgba(3, 8, 14, 0.18)" : "rgba(211, 242, 255, 0.2)";
      const trail = darkTheme ? "#37ff9f" : "#0f58ff";
      const head = darkTheme ? "#d8ffe8" : "#162d70";

      matrixCtx.fillStyle = fade;
      matrixCtx.fillRect(0, 0, matrixCanvas.width, matrixCanvas.height);

      for (let i = 0; i < matrix.drops.length; i += 1) {
        const x = i * matrix.fontSize;
        const y = matrix.drops[i] * matrix.fontSize;
        const char = matrix.chars[Math.floor(Math.random() * matrix.chars.length)];

        matrixCtx.fillStyle = Math.random() > 0.9 ? head : trail;
        matrixCtx.fillText(char, x, y);

        if (y > matrixCanvas.height && Math.random() > 0.975) {
          matrix.drops[i] = 0;
        } else {
          matrix.drops[i] += 0.8 + Math.random() * 0.75;
        }
      }
    }

    function freqFromSemitone(root, offset) {
      return root * Math.pow(2, offset / 12);
    }

    function ensureAudio() {
      if (!audioCtx) {
        audioCtx = new AudioContext();
        masterGain = audioCtx.createGain();
        sfxGain = audioCtx.createGain();
        masterGain.gain.value = 0.16 * state.settings.musicVolume;
        sfxGain.gain.value = state.settings.sfxVolume;
        masterGain.connect(audioCtx.destination);
        sfxGain.connect(audioCtx.destination);
      }
      if (audioCtx.state === "suspended") {
        audioCtx.resume();
      }
    }

    function playSfx(kind) {
      ensureAudio();
      if (!audioCtx || !sfxGain) return;
      const now = audioCtx.currentTime;
      if (kind === "shoot") {
        synthHit({ freq: 520 + Math.random() * 70, time: now, dur: 0.06, type: "triangle", gain: 0.05, bus: sfxGain });
      } else if (kind === "hit") {
        synthHit({ freq: 190 + Math.random() * 30, time: now, dur: 0.08, type: "sawtooth", gain: 0.045, bus: sfxGain });
      } else if (kind === "reload") {
        synthHit({ freq: 280, time: now, dur: 0.08, type: "square", gain: 0.038, bus: sfxGain });
        synthHit({ freq: 350, time: now + 0.08, dur: 0.06, type: "square", gain: 0.034, bus: sfxGain });
      } else if (kind === "dash") {
        synthHit({ freq: 720, time: now, dur: 0.07, type: "triangle", gain: 0.04, bus: sfxGain });
      } else if (kind === "upgrade") {
        synthHit({ freq: 440, time: now, dur: 0.07, type: "sine", gain: 0.045, bus: sfxGain });
        synthHit({ freq: 660, time: now + 0.09, dur: 0.09, type: "sine", gain: 0.04, bus: sfxGain });
      } else if (kind === "swap") {
        synthHit({ freq: 300, time: now, dur: 0.06, type: "triangle", gain: 0.035, bus: sfxGain });
      }
    }

    function synthHit({ freq, time, dur, type, gain, detune = 0, bus = masterGain }) {
      const osc = audioCtx.createOscillator();
      const env = audioCtx.createGain();

      osc.type = type;
      osc.frequency.setValueAtTime(freq, time);
      osc.detune.setValueAtTime(detune, time);

      env.gain.setValueAtTime(0.0001, time);
      env.gain.exponentialRampToValueAtTime(gain, time + 0.01);
      env.gain.exponentialRampToValueAtTime(0.0001, time + dur);

      osc.connect(env);
      env.connect(bus);
      osc.start(time);
      osc.stop(time + dur + 0.03);
    }

    function triggerKick(time) {
      const osc = audioCtx.createOscillator();
      const env = audioCtx.createGain();
      osc.type = "sine";
      osc.frequency.setValueAtTime(130, time);
      osc.frequency.exponentialRampToValueAtTime(45, time + 0.12);
      env.gain.setValueAtTime(0.0001, time);
      env.gain.exponentialRampToValueAtTime(0.2, time + 0.01);
      env.gain.exponentialRampToValueAtTime(0.0001, time + 0.18);
      osc.connect(env);
      env.connect(masterGain);
      osc.start(time);
      osc.stop(time + 0.2);
    }

    function stopMusic() {
      if (sequenceTimer) {
        clearInterval(sequenceTimer);
        sequenceTimer = null;
      }
      audioState.textContent = "Audio: Off";
    }

    function startMusic(trackName) {
      if (trackName === "off") {
        stopMusic();
        return;
      }

      ensureAudio();
      if (sequenceTimer) clearInterval(sequenceTimer);

      const track = tracks[trackName];
      const stepMs = (60_000 / track.bpm) / 2;
      beatIndex = 0;
      audioState.textContent = `Audio: ${musicSelect.options[musicSelect.selectedIndex].text}`;

      sequenceTimer = setInterval(() => {
        if (!audioCtx) return;
        const now = audioCtx.currentTime;
        const leadStep = beatIndex % track.lead.length;
        const bassStep = beatIndex % track.bass.length;

        const leadFreq = freqFromSemitone(220, track.lead[leadStep]);
        const bassFreq = freqFromSemitone(110, track.bass[bassStep]);

        synthHit({ freq: leadFreq, time: now, dur: 0.16, type: "square", gain: 0.035 });
        synthHit({ freq: leadFreq * 2, time: now, dur: 0.08, type: "triangle", gain: 0.012, detune: 4 });

        if (beatIndex % 2 === 0) {
          synthHit({ freq: bassFreq, time: now, dur: 0.22, type: "sawtooth", gain: 0.028 });
        }

        if (beatIndex % 4 === 0) {
          triggerKick(now);
        }

        beatIndex += 1;
      }, stepMs);
    }

    function burst(x, y, color) {
      for (let i = 0; i < 9; i += 1) {
        const angle = Math.random() * Math.PI * 2;
        const speed = 1.2 + Math.random() * 3.1;
        state.particles.push({
          x,
          y,
          vx: Math.cos(angle) * speed,
          vy: Math.sin(angle) * speed,
          life: 26 + Math.random() * 24,
          color,
        });
      }
    }

    function endRun(cause) {
      if (!state.running) return;
      state.running = false;
      state.firing = false;
      state.cause = cause;
      state.best = Math.max(state.best, Math.floor(state.score));
      localStorage.setItem("neon_dodge_best", String(state.best));
      saveSettings();
      burst(state.player.x, state.player.y, "#ff5b9f");
    }

    function switchBiome() {
      if (state.biomeMode !== "auto") return;
      state.biome = state.biome === "city" ? "metro" : "city";
      state.biomeTimer = 1400 + Math.floor(Math.random() * 500);
      state.weatherCooldown = 120 + Math.floor(Math.random() * 180);
      burst(canvas.width * 0.72, canvas.height * 0.24, state.biome === "city" ? "#23f7ff" : "#d8ffe8");
    }

    function startExtraction() {
      const h = 96;
      const w = 128;
      const y = 68 + Math.random() * (canvas.height - h - 136);
      state.extraction = {
        x: canvas.width - 180,
        y,
        w,
        h,
        hold: 0,
        holdNeed: 82,
        timer: 900,
      };
      state.missionPhase = "extract";
      burst(canvas.width - 120, y + h * 0.5, "#8dd7ff");
    }

    function completeExtraction() {
      state.missionsCompleted += 1;
      state.scrap += 22 + Math.floor(state.difficulty * 7);
      state.missionPhase = "travel";
      state.missionProgress = 0;
      state.battery = Math.min(100, state.battery + 16);
      state.extraction = null;
      if (state.enemies.length > 6) {
        state.enemies.splice(0, Math.floor(state.enemies.length * 0.45));
      }
      if (state.missionsCompleted % 3 === 0) {
        spawnBoss();
      }
      chooseMission();
      saveSettings();
      burst(state.player.x + 40, state.player.y, "#23f7ff");
      burst(state.player.x + 70, state.player.y - 20, "#8effcf");
    }

    function chooseMission() {
      const pool = ["sync", "hunt", "survive"];
      state.missionKind = pool[Math.floor(Math.random() * pool.length)];
      state.missionCounter = 0;
      state.surviveTicks = 0;
      state.killsThisMission = 0;
      if (state.missionKind === "sync") {
        state.missionTarget = Math.min(1650, 560 + state.missionsCompleted * 140);
      } else if (state.missionKind === "hunt") {
        state.missionTarget = 6 + state.missionsCompleted * 2;
      } else {
        state.missionTarget = 480 + state.missionsCompleted * 100;
      }
    }

    function spawnBoss() {
      state.enemies.push({
        type: "boss",
        x: canvas.width + 120,
        y: canvas.height / 2,
        r: 44,
        hp: 30 + state.missionsCompleted * 6,
        speed: 1.7 + state.difficulty * 0.16,
        phase: 0,
        fireCd: 42,
        lock: 0,
        aimX: 0,
        aimY: 0,
        cooldown: 0,
        charge: 0,
        chargeVy: 0,
      });
      state.bossActive = true;
    }

    function takeDamage(amount, sx, sy, cause) {
      if (!state.running) return;
      if (state.playerIframes > 0) return;
      state.health = Math.max(0, state.health - amount);
      state.hitFlash = Math.max(state.hitFlash, 0.55);
      state.screenShake = Math.max(state.screenShake, Math.min(22, amount * 0.5));
      state.playerIframes = amount >= 1 ? 20 : 3;
      const dx = sx - state.player.x;
      const dy = sy - state.player.y;
      state.lastHitAngle = Math.atan2(dy, dx);
      playSfx("hit");
      if (state.health <= 0) {
        endRun(cause);
      }
    }

    function triggerDash() {
      if (!state.running) return;
      if (state.dash.cooldown > 0 || state.dash.stamina < 16) return;
      const p = state.player;
      let dx = 0;
      let dy = 0;
      if (state.keys.has("arrowup") || state.keys.has("w")) dy -= 1;
      if (state.keys.has("arrowdown") || state.keys.has("s")) dy += 1;
      if (state.keys.has("arrowleft") || state.keys.has("a")) dx -= 1;
      if (state.keys.has("arrowright") || state.keys.has("d")) dx += 1;
      if (dx === 0 && dy === 0) {
        dx = p.facingX || 1;
        dy = p.facingY || 0;
      }
      const len = Math.hypot(dx, dy) || 1;
      const power = 62 + state.upgrades.dash * 10;
      p.x += (dx / len) * power;
      p.y += (dy / len) * power;
      state.dash.stamina = Math.max(0, state.dash.stamina - 18);
      state.dash.cooldown = Math.max(12, state.dash.cooldownMax - state.upgrades.dash * 3);
      state.screenShake = Math.max(state.screenShake, 8);
      playSfx("dash");
    }

    function reset() {
      state.player.x = 120;
      state.player.y = canvas.height / 2;
      state.player.facingX = 1;
      state.player.facingY = 0;
      state.player.aimX = null;
      state.player.aimY = null;
      state.enemies = [];
      state.playerShots = [];
      state.particles = [];
      state.pickups = [];
      state.shots = [];
      state.weatherEvents = [];
      state.score = 0;
      state.spawnTimer = 0;
      state.pickupTimer = 260;
      state.weatherCooldown = 320;
      state.running = true;
      state.tick = 0;
      state.biome = state.biomeMode === "metro" ? "metro" : "city";
      state.biomeTimer = 1600;
      state.battery = 100;
      state.healthMax = 100 + state.upgrades.maxHealth * 12;
      state.health = state.healthMax;
      state.missionsCompleted = 0;
      state.missionPhase = "travel";
      state.missionProgress = 0;
      state.missionTarget = 700;
      state.extraction = null;
      state.bossActive = false;
      state.difficulty = 1;
      state.firing = false;
      state.dash.staminaMax = 100 + state.upgrades.dash * 14;
      state.dash.stamina = state.dash.staminaMax;
      state.dash.cooldown = 0;
      state.weapon.reloadTimer = 0;
      state.weapon.fireCooldown = 0;
      applyWeaponProfile(state.weapon.type);
      state.weapon.ammo = state.weapon.ammoMax;
      chooseMission();
      state.cause = "";
    }

    function updateMission() {
      if (!state.running) return;
      if (state.bossActive) return;

      if (state.missionPhase === "travel") {
        if (state.missionKind === "sync") {
          state.missionProgress += 1 + state.score / 4000;
          if (state.missionProgress >= state.missionTarget) startExtraction();
        } else if (state.missionKind === "hunt") {
          state.missionCounter = state.killsThisMission;
          if (state.missionCounter >= state.missionTarget) startExtraction();
        } else {
          state.surviveTicks += 1;
          state.missionCounter = state.surviveTicks;
          if (state.missionCounter >= state.missionTarget) startExtraction();
        }
        return;
      }

      if (!state.extraction) {
        startExtraction();
        return;
      }

      state.extraction.timer -= 1;
      if (state.extraction.timer <= 0) {
        endRun("Missed extraction window");
        return;
      }

      const e = state.extraction;
      const px = state.player.x;
      const py = state.player.y;
      const inside = px > e.x && px < e.x + e.w && py > e.y && py < e.y + e.h;

      if (inside) {
        e.hold = Math.min(e.holdNeed, e.hold + 1.4);
        if (state.tick % 4 === 0) burst(px + Math.random() * 8, py + Math.random() * 8, "#8de5ff");
      } else {
        e.hold = Math.max(0, e.hold - 1);
      }

      if (e.hold >= e.holdNeed) {
        completeExtraction();
      }
    }

    function spawnEnemy() {
      const roll = Math.random();
      const inCity = state.biome === "city";
      let type = "drone";

      if (inCity) {
        if (roll > 0.72) type = "turret";
        if (roll > 0.9) type = "mutant";
      } else {
        if (roll < 0.56) type = "mutant";
        else if (roll > 0.8) type = "turret";
      }

      const radiusByType = { drone: 14, mutant: 19, turret: 16 };
      const speedByType = { drone: 4.2, mutant: 3.25, turret: 2.8 };
      const r = radiusByType[type] + Math.random() * 8;
      const hpScale = 1 + state.difficulty * 0.18;

      state.enemies.push({
        type,
        x: canvas.width + r,
        y: r + Math.random() * (canvas.height - r * 2),
        r,
        hp: Math.ceil((type === "mutant" ? 3 : (type === "turret" ? 4 : 2)) * hpScale),
        speed: speedByType[type] + Math.random() * 1.7 + state.score / 500 + state.difficulty * 0.25,
        phase: Math.random() * Math.PI * 2,
        cooldown: 90 + Math.random() * 80,
        charge: 0,
        chargeVy: 0,
        fireCd: 70 + Math.random() * 80,
        blink: Math.random() * 100,
        lock: 0,
        aimX: 0,
        aimY: 0,
      });
    }

    function spawnShot(enemy) {
      const tx = enemy.aimX || state.player.x;
      const ty = enemy.aimY || state.player.y;
      const angle = Math.atan2(ty - enemy.y, tx - enemy.x);
      state.shots.push({
        x: enemy.x,
        y: enemy.y,
        vx: Math.cos(angle) * 6.2,
        vy: Math.sin(angle) * 6.2,
        r: 4,
      });
      burst(enemy.x, enemy.y, "#ff9b4f");
    }

    function getPlayerAimAngle() {
      const p = state.player;
      const ax = p.aimX;
      const ay = p.aimY;
      if (typeof ax === "number" && typeof ay === "number") {
        return Math.atan2(ay - p.y, ax - p.x);
      }
      return Math.atan2(p.facingY || 0, p.facingX || 1);
    }

    function firePlayerShot() {
      if (!state.running) return;
      const w = state.weapon;
      if (w.reloadTimer > 0 || w.fireCooldown > 0) return;

      if (w.ammo <= 0) {
        w.reloadTimer = w.reloadDuration;
        return;
      }

      const p = state.player;
      const angle = getPlayerAimAngle();
      const profile = weaponProfiles[w.type];
      const pellets = profile.pellets || 1;
      for (let i = 0; i < pellets; i += 1) {
        const spread = (Math.random() - 0.5) * 2 * profile.spread;
        const shotAngle = angle + spread;
        state.playerShots.push({
          x: p.x + Math.cos(shotAngle) * (p.r + 4),
          y: p.y + Math.sin(shotAngle) * (p.r + 4),
          vx: Math.cos(shotAngle) * profile.speed,
          vy: Math.sin(shotAngle) * profile.speed,
          r: 3.2,
          damage: w.damage,
        });
      }
      w.ammo -= 1;
      w.fireCooldown = w.fireRate;
      burst(p.x + Math.cos(angle) * (p.r + 3), p.y + Math.sin(angle) * (p.r + 3), "#fff5c1");
      playSfx("shoot");
      if (w.ammo <= 0) {
        w.reloadTimer = w.reloadDuration;
      }
    }

    function updateWeapon() {
      const w = state.weapon;
      if (w.fireCooldown > 0) w.fireCooldown -= 1;
      if (w.reloadTimer > 0) {
        w.reloadTimer -= 1;
        if (w.reloadTimer <= 0) {
          w.ammo = w.ammoMax;
          w.reloadTimer = 0;
          playSfx("reload");
        }
      }
      if (state.firing) firePlayerShot();
    }

    function updatePlayerShots() {
      for (let i = state.playerShots.length - 1; i >= 0; i -= 1) {
        const s = state.playerShots[i];
        s.x += s.vx;
        s.y += s.vy;

        let hit = false;
        for (let j = state.enemies.length - 1; j >= 0; j -= 1) {
          const e = state.enemies[j];
          const dx = e.x - s.x;
          const dy = e.y - s.y;
          if (Math.hypot(dx, dy) <= e.r + s.r) {
            e.hp -= s.damage;
            burst(s.x, s.y, "#ffdca1");
            hit = true;
            if (e.hp <= 0) {
              burst(e.x, e.y, "#ffb07a");
              playSfx("hit");
              state.score += 26;
              state.killsThisMission += 1;
              state.scrap += 3;
              if (e.type === "boss") {
                state.score += 250;
                state.scrap += 60;
                state.bossActive = false;
              }
              state.enemies.splice(j, 1);
            }
            break;
          }
        }

        if (hit) {
          state.playerShots.splice(i, 1);
          continue;
        }

        if (s.x < -30 || s.x > canvas.width + 30 || s.y < -30 || s.y > canvas.height + 30) {
          state.playerShots.splice(i, 1);
        }
      }
    }

    function spawnWeatherEvent() {
      if (state.biome === "city") {
        const width = 28 + Math.random() * 50;
        state.weatherEvents.push({
          type: "storm",
          x: 140 + Math.random() * (canvas.width - 220),
          width,
          warn: 68,
          strike: 22,
        });
      } else {
        const r = 38 + Math.random() * 30;
        state.weatherEvents.push({
          type: "gas",
          x: canvas.width + r,
          y: 60 + Math.random() * (canvas.height - 120),
          r,
          life: 360,
          drift: -(1.1 + Math.random() * 1.1),
        });
      }
    }

    function spawnLoot(kind = "battery") {
      const colorByKind = {
        battery: "#8effcf",
        ammo: "#9dc4ff",
        med: "#ff97a8",
        boost: "#ffd993",
      };
      state.pickups.push({
        x: canvas.width + 22,
        y: 60 + Math.random() * (canvas.height - 120),
        r: 10,
        amount: 28 + Math.random() * 24,
        kind,
        color: colorByKind[kind] || "#8effcf",
        life: 850,
      });
    }

    function updateWeather() {
      if (state.running) {
        state.weatherCooldown -= 1;
        if (state.weatherCooldown <= 0) {
          spawnWeatherEvent();
          const nextCd = state.biome === "city"
            ? 230 + Math.floor(Math.random() * 180) - Math.floor(state.difficulty * 8)
            : 190 + Math.floor(Math.random() * 170) - Math.floor(state.difficulty * 8);
          state.weatherCooldown = Math.max(95, nextCd);
        }
      }

      for (let i = state.weatherEvents.length - 1; i >= 0; i -= 1) {
        const w = state.weatherEvents[i];

        if (w.type === "storm") {
          if (w.warn > 0) {
            w.warn -= 1;
          } else if (w.strike > 0) {
            w.strike -= 1;
            if (state.running && Math.abs(state.player.x - w.x) < w.width * 0.5) {
              takeDamage(14, w.x, state.player.y, "Electrocuted");
            }
          } else {
            state.weatherEvents.splice(i, 1);
          }
        } else {
          w.x += w.drift;
          w.life -= 1;
          const dx = state.player.x - w.x;
          const dy = state.player.y - w.y;

          if (state.running && Math.hypot(dx, dy) < w.r + state.player.r) {
            state.battery = Math.max(0, state.battery - 0.36);
            takeDamage(0.14, w.x, w.y, "Toxic exposure");
            if (state.battery <= 0) endRun("Toxic exposure");
          }

          if (w.life <= 0 || w.x + w.r < -20) {
            state.weatherEvents.splice(i, 1);
          }
        }
      }
    }

    function updatePickups() {
      if (state.running) {
        state.pickupTimer -= 1;
        if (state.pickupTimer <= 0) {
          const roll = Math.random();
          if (roll < 0.34) spawnLoot("battery");
          else if (roll < 0.68) spawnLoot("ammo");
          else if (roll < 0.88) spawnLoot("med");
          else spawnLoot("boost");
          state.pickupTimer = 180 + Math.floor(Math.random() * 180);
        }
      }

      for (let i = state.pickups.length - 1; i >= 0; i -= 1) {
        const p = state.pickups[i];
        p.x -= 1.6;
        p.y += Math.sin((state.tick + i * 12) * 0.06) * 0.65;

        const dx = state.player.x - p.x;
        const dy = state.player.y - p.y;
        if (state.running && Math.hypot(dx, dy) < state.player.r + p.r) {
          if (p.kind === "battery") {
            state.battery = Math.min(100, state.battery + p.amount);
          } else if (p.kind === "ammo") {
            state.weapon.ammo = Math.min(state.weapon.ammoMax, state.weapon.ammo + 7);
          } else if (p.kind === "med") {
            state.health = Math.min(state.healthMax, state.health + 22);
          } else {
            state.weapon.fireCooldown = Math.max(0, state.weapon.fireCooldown - 3);
            state.dash.stamina = Math.min(state.dash.staminaMax, state.dash.stamina + 24);
          }
          burst(p.x, p.y, p.color);
          state.pickups.splice(i, 1);
          continue;
        }

        p.life -= 1;
        if (p.x + p.r < -16) state.pickups.splice(i, 1);
        if (p.life <= 0) state.pickups.splice(i, 1);
      }
    }

    function updateShots() {
      for (let i = state.shots.length - 1; i >= 0; i -= 1) {
        const s = state.shots[i];
        s.x += s.vx;
        s.y += s.vy;

        const dx = state.player.x - s.x;
        const dy = state.player.y - s.y;
        if (state.running && Math.hypot(dx, dy) < state.player.r + s.r) {
          takeDamage(13, s.x, s.y, "Sniped");
          state.shots.splice(i, 1);
          continue;
        }

        if (s.x < -20 || s.x > canvas.width + 20 || s.y < -20 || s.y > canvas.height + 20) {
          state.shots.splice(i, 1);
        }
      }
    }

    function updateEnemies() {
      const p = state.player;

      for (let i = state.enemies.length - 1; i >= 0; i -= 1) {
        const e = state.enemies[i];

        if (e.type === "drone") {
          e.x -= e.speed;
          e.y += Math.sin((state.tick + e.phase * 40) * 0.095) * 1.7;
          e.blink = (e.blink || 0) - 1;
          if (e.blink <= 0) {
            e.speed += 0.15;
            e.blink = 80 + Math.random() * 120;
          }
        } else if (e.type === "mutant") {
          if (e.charge > 0) {
            e.charge -= 1;
            e.x -= e.speed * 2.3;
            e.y += e.chargeVy;
          } else {
            e.x -= e.speed * 0.85;
            const pull = Math.sign(p.y - e.y) * Math.min(1.6, Math.abs(p.y - e.y) * 0.03);
            e.y += pull;
            e.cooldown -= 1;
            if (e.cooldown <= 0 && e.x > p.x + 60) {
              e.charge = 28;
              e.chargeVy = (p.y - e.y) / 26;
              e.cooldown = 85 + Math.random() * 75;
            }
          }
        } else if (e.type === "boss") {
          if (e.x > canvas.width * 0.74) e.x -= 0.8;
          e.phase += 0.035;
          e.y += Math.sin(e.phase) * 2.2;
          e.fireCd -= 1;
          if (e.fireCd <= 0) {
            for (let a = -1; a <= 1; a += 1) {
              const tx = p.x + a * 35;
              const ty = p.y + a * 15;
              const ang = Math.atan2(ty - e.y, tx - e.x);
              state.shots.push({
                x: e.x,
                y: e.y,
                vx: Math.cos(ang) * 5.2,
                vy: Math.sin(ang) * 5.2,
                r: 5,
              });
            }
            e.fireCd = 44;
          }
        } else {
          if (e.x > canvas.width * 0.78) e.x -= 1.5;
          if (e.lock > 0) {
            e.lock -= 1;
            if (e.lock === 0) spawnShot(e);
          } else {
            e.fireCd -= 1;
            if (e.fireCd <= 0) {
              e.lock = 34;
              e.aimX = p.x;
              e.aimY = p.y;
              e.fireCd = 92 + Math.random() * 70;
            }
          }
        }

        e.y = Math.max(e.r, Math.min(canvas.height - e.r, e.y));

        const dx = p.x - e.x;
        const dy = p.y - e.y;
        if (state.running && Math.hypot(dx, dy) <= p.r + e.r) {
          const reason = e.type === "mutant" ? "Mauled" : (e.type === "turret" ? "Crushed" : (e.type === "boss" ? "Overrun" : "Shredded"));
          const damage = e.type === "boss" ? 22 : (e.type === "mutant" ? 18 : (e.type === "turret" ? 14 : 12));
          takeDamage(damage, e.x, e.y, reason);
        }

        if (e.x + e.r < -30) {
          if (e.type === "boss") state.bossActive = false;
          state.enemies.splice(i, 1);
          burst(e.x, e.y, "#23f7ff");
        }
      }
    }

    function update() {
      if (state.running) {
        state.tick += 1;
        state.spawnTimer -= 1;
        state.difficulty = 1 + state.score / 2200 + state.missionsCompleted * 0.1;
        if (state.dash.cooldown > 0) state.dash.cooldown -= 1;
        state.dash.stamina = Math.min(state.dash.staminaMax, state.dash.stamina + 0.2 + state.upgrades.dash * 0.04);
        if (state.playerIframes > 0) state.playerIframes -= 1;
        if (state.biomeMode === "auto") {
          state.biomeTimer -= 1;

          if (state.biomeTimer <= 0) {
            switchBiome();
          }
        }

        if (state.spawnTimer <= 0) {
          if (!state.bossActive) spawnEnemy();
          state.spawnTimer = Math.max(13, 40 - Math.floor(state.score / 140) - Math.floor(state.difficulty * 1.6));
        }

        const p = state.player;
        let moved = false;

        if (state.keys.has("arrowup") || state.keys.has("w")) {
          p.y -= p.speed;
          p.facingX = 0;
          p.facingY = -1;
          moved = true;
        }
        if (state.keys.has("arrowdown") || state.keys.has("s")) {
          p.y += p.speed;
          p.facingX = 0;
          p.facingY = 1;
          moved = true;
        }
        if (state.keys.has("arrowleft") || state.keys.has("a")) {
          p.x -= p.speed;
          p.facingX = -1;
          p.facingY = 0;
          moved = true;
        }
        if (state.keys.has("arrowright") || state.keys.has("d")) {
          p.x += p.speed;
          p.facingX = 1;
          p.facingY = 0;
          moved = true;
        }

        if (!moved && p.facingX === 0 && p.facingY === 0) {
          p.facingX = 1;
          p.facingY = 0;
        }

        p.x = Math.max(p.r, Math.min(canvas.width - p.r, p.x));
        p.y = Math.max(p.r, Math.min(canvas.height - p.r, p.y));

        if (state.biome === "metro") {
          state.battery = Math.max(0, state.battery - 0.03);
          if (state.battery <= 0) endRun("Battery depleted");
        } else {
          state.battery = Math.min(100, state.battery + 0.045);
        }

        updateMission();
        updateWeather();
        updatePickups();
        updateWeapon();
        updatePlayerShots();
        updateEnemies();
        updateShots();

        if (state.tick % 5 === 0) {
          burst(p.x - 8, p.y, "#23f7ff");
        }

        state.score += 1;
      } else {
        updateWeather();
        updatePickups();
        updateWeapon();
        updatePlayerShots();
        updateShots();
        state.screenShake *= 0.85;
      }

      for (let i = state.particles.length - 1; i >= 0; i -= 1) {
        const p = state.particles[i];
        p.x += p.vx;
        p.y += p.vy;
        p.vx *= 0.985;
        p.vy *= 0.985;
        p.life -= 1;
        if (p.life <= 0) state.particles.splice(i, 1);
      }

      state.hitFlash = Math.max(0, state.hitFlash - 0.03);

      updateHud();
    }

    function drawGrid() {
      ctx.save();
      ctx.globalAlpha = state.biome === "metro" ? 0.22 : 0.45;
      ctx.strokeStyle = getComputedStyle(document.documentElement).getPropertyValue("--grid").trim();
      ctx.lineWidth = 1;
      const gap = 34;
      const shift = (state.tick * 0.95) % gap;

      for (let x = -gap + shift; x < canvas.width + gap; x += gap) {
        ctx.beginPath();
        ctx.moveTo(x, 0);
        ctx.lineTo(x, canvas.height);
        ctx.stroke();
      }
      for (let y = 0; y < canvas.height; y += gap) {
        ctx.beginPath();
        ctx.moveTo(0, y);
        ctx.lineTo(canvas.width, y);
        ctx.stroke();
      }
      ctx.restore();
    }

    function drawGroundShadow(x, y, rx, ry) {
      ctx.save();
      const g = ctx.createRadialGradient(x, y, 2, x, y, rx);
      g.addColorStop(0, "rgba(0, 0, 0, 0.35)");
      g.addColorStop(1, "rgba(0, 0, 0, 0)");
      ctx.fillStyle = g;
      ctx.beginPath();
      ctx.ellipse(x, y, rx, ry, 0, 0, Math.PI * 2);
      ctx.fill();
      ctx.restore();
    }

    function drawPlayerModel(p, primary, aimAngle) {
      drawGroundShadow(p.x + 2, p.y + p.r + 8, p.r * 1.6, p.r * 0.62);
      ctx.save();
      ctx.translate(p.x, p.y);

      const bodyGrad = ctx.createRadialGradient(-p.r * 0.45, -p.r * 0.55, 2, 0, 0, p.r * 1.22);
      bodyGrad.addColorStop(0, "#f4fbff");
      bodyGrad.addColorStop(0.26, primary);
      bodyGrad.addColorStop(0.7, "#1d5f89");
      bodyGrad.addColorStop(1, "#0b263d");
      ctx.fillStyle = bodyGrad;
      ctx.shadowBlur = 22;
      ctx.shadowColor = primary;
      ctx.beginPath();
      ctx.ellipse(0, 0, p.r * 1.04, p.r * 0.95, 0, 0, Math.PI * 2);
      ctx.fill();

      ctx.shadowBlur = 0;
      ctx.fillStyle = "rgba(16, 38, 64, 0.65)";
      ctx.beginPath();
      ctx.ellipse(2, 5, p.r * 0.88, p.r * 0.56, 0, 0, Math.PI * 2);
      ctx.fill();

      const visorGrad = ctx.createLinearGradient(-p.r * 0.46, -p.r * 0.2, p.r * 0.56, -p.r * 0.34);
      visorGrad.addColorStop(0, "#f4ffff");
      visorGrad.addColorStop(1, "#8be7ff");
      ctx.fillStyle = visorGrad;
      ctx.beginPath();
      ctx.roundRect(-p.r * 0.56, -p.r * 0.43, p.r * 1.05, p.r * 0.4, p.r * 0.15);
      ctx.fill();

      ctx.strokeStyle = "rgba(255, 255, 255, 0.7)";
      ctx.lineWidth = 1.1;
      ctx.beginPath();
      ctx.arc(-p.r * 0.25, -p.r * 0.34, p.r * 0.25, 0, Math.PI * 1.6);
      ctx.stroke();

      ctx.rotate(aimAngle);
      const gun = ctx.createLinearGradient(p.r * 0.2, -2, p.r * 1.05, 2);
      gun.addColorStop(0, "#d0d7e4");
      gun.addColorStop(1, "#4d596f");
      ctx.fillStyle = gun;
      ctx.beginPath();
      ctx.roundRect(p.r * 0.1, -2.4, p.r * 0.96, 4.8, 2);
      ctx.fill();
      ctx.fillStyle = "#f1f7ff";
      ctx.fillRect(p.r * 0.92, -1.2, 3.4, 2.4);

      ctx.restore();
    }

    function drawDroneModel(e, secondary) {
      drawGroundShadow(e.x + 2, e.y + e.r + 8, e.r * 1.45, e.r * 0.58);
      ctx.save();
      ctx.translate(e.x, e.y);
      ctx.shadowBlur = 18;
      ctx.shadowColor = secondary;

      const shell = ctx.createRadialGradient(-e.r * 0.35, -e.r * 0.45, 2, 0, 0, e.r * 1.24);
      shell.addColorStop(0, "#ffeefa");
      shell.addColorStop(0.32, secondary);
      shell.addColorStop(1, "#52103a");
      ctx.fillStyle = shell;
      ctx.beginPath();
      ctx.ellipse(0, 0, e.r * 1.05, e.r * 0.92, 0, 0, Math.PI * 2);
      ctx.fill();

      ctx.shadowBlur = 0;
      ctx.fillStyle = "#1b0f28cc";
      ctx.beginPath();
      ctx.ellipse(0, e.r * 0.15, e.r * 0.72, e.r * 0.42, 0, 0, Math.PI * 2);
      ctx.fill();

      ctx.strokeStyle = "rgba(255, 255, 255, 0.55)";
      ctx.lineWidth = 1;
      ctx.beginPath();
      ctx.moveTo(-e.r * 0.7, -e.r * 0.2);
      ctx.lineTo(e.r * 0.7, -e.r * 0.35);
      ctx.stroke();

      ctx.fillStyle = "#ffe5f3";
      ctx.beginPath();
      ctx.arc(-e.r * 0.2, -e.r * 0.4, e.r * 0.15, 0, Math.PI * 2);
      ctx.fill();
      ctx.restore();
    }

    function drawMutantModel(e) {
      drawGroundShadow(e.x + 3, e.y + e.r + 9, e.r * 1.5, e.r * 0.66);
      ctx.save();
      ctx.translate(e.x, e.y);
      ctx.shadowBlur = 16;
      ctx.shadowColor = "#ff7a40";

      const skin = ctx.createRadialGradient(-e.r * 0.25, -e.r * 0.45, 1, 0, 0, e.r * 1.3);
      skin.addColorStop(0, "#ffd8bf");
      skin.addColorStop(0.34, "#ff985f");
      skin.addColorStop(1, "#6b1f15");
      ctx.fillStyle = skin;
      ctx.beginPath();
      ctx.ellipse(0, 0, e.r * 1.08, e.r * 0.84, 0, 0, Math.PI * 2);
      ctx.fill();

      ctx.shadowBlur = 0;
      ctx.fillStyle = "#0000002e";
      ctx.beginPath();
      ctx.ellipse(e.r * 0.15, e.r * 0.18, e.r * 0.7, e.r * 0.35, 0, 0, Math.PI * 2);
      ctx.fill();

      ctx.fillStyle = "#2c1115";
      ctx.beginPath();
      ctx.ellipse(e.r * 0.28, -e.r * 0.18, e.r * 0.12, e.r * 0.1, 0, 0, Math.PI * 2);
      ctx.fill();

      ctx.fillStyle = "#fff3ea";
      ctx.beginPath();
      ctx.arc(-e.r * 0.16, -e.r * 0.34, e.r * 0.1, 0, Math.PI * 2);
      ctx.fill();
      ctx.restore();
    }

    function drawTurretModel(e) {
      drawGroundShadow(e.x + 3, e.y + e.r + 8, e.r * 1.5, e.r * 0.58);
      ctx.save();
      ctx.translate(e.x, e.y);
      ctx.shadowBlur = 14;
      ctx.shadowColor = "#ffb24f";

      const steel = ctx.createLinearGradient(-e.r, -e.r, e.r, e.r);
      steel.addColorStop(0, "#ffe3be");
      steel.addColorStop(0.4, "#ce8947");
      steel.addColorStop(1, "#543118");
      ctx.fillStyle = steel;
      ctx.beginPath();
      ctx.roundRect(-e.r, -e.r, e.r * 2, e.r * 2, e.r * 0.22);
      ctx.fill();

      ctx.shadowBlur = 0;
      ctx.fillStyle = "#251106cc";
      ctx.beginPath();
      ctx.roundRect(-e.r * 0.82, -e.r * 0.24, e.r * 1.64, e.r * 0.9, e.r * 0.18);
      ctx.fill();

      const turretHead = ctx.createRadialGradient(-e.r * 0.1, -e.r * 0.2, 2, 0, 0, e.r * 0.72);
      turretHead.addColorStop(0, "#fff4d7");
      turretHead.addColorStop(1, "#7d4a21");
      ctx.fillStyle = turretHead;
      ctx.beginPath();
      ctx.arc(0, -e.r * 0.05, e.r * 0.48, 0, Math.PI * 2);
      ctx.fill();

      ctx.fillStyle = "#311603";
      ctx.fillRect(e.r * 0.05, -e.r * 0.12, e.r * 0.62, e.r * 0.22);
      ctx.restore();
    }

    function drawBossModel(e) {
      drawGroundShadow(e.x + 6, e.y + e.r + 12, e.r * 1.8, e.r * 0.7);
      ctx.save();
      ctx.translate(e.x, e.y);
      ctx.shadowBlur = 22;
      ctx.shadowColor = "#ff697f";
      const shell = ctx.createRadialGradient(-e.r * 0.3, -e.r * 0.4, 2, 0, 0, e.r * 1.45);
      shell.addColorStop(0, "#ffe0e7");
      shell.addColorStop(0.35, "#ff6e9f");
      shell.addColorStop(1, "#411531");
      ctx.fillStyle = shell;
      ctx.beginPath();
      ctx.ellipse(0, 0, e.r * 1.08, e.r * 0.94, 0, 0, Math.PI * 2);
      ctx.fill();
      ctx.shadowBlur = 0;
      ctx.fillStyle = "#fff6";
      ctx.fillRect(e.r * 0.2, -2, e.r * 0.72, 4);
      ctx.restore();
    }

    function getTorchParams() {
      const p = state.player;
      const aimX = p.facingX === 0 && p.facingY === 0 ? 1 : p.facingX;
      const aimY = p.facingX === 0 && p.facingY === 0 ? 0 : p.facingY;
      return {
        x: p.x,
        y: p.y,
        angle: Math.atan2(aimY, aimX),
        spread: 0.64,
        range: 180 + state.battery * 2.8,
      };
    }

    function getEnemyVisibility(e) {
      if (state.biome !== "metro") return 1;

      const t = getTorchParams();
      const dx = e.x - t.x;
      const dy = e.y - t.y;
      const dist = Math.hypot(dx, dy);

      if (dist < 1) return 1;

      const targetAngle = Math.atan2(dy, dx);
      const angleDiff = Math.abs(Math.atan2(Math.sin(targetAngle - t.angle), Math.cos(targetAngle - t.angle)));

      const angleFalloff = Math.max(0, 1 - (angleDiff / (t.spread * 1.2)));
      const distFalloff = Math.max(0, 1 - (dist / (t.range * 1.1)));
      const nearReveal = dist < 90 ? (1 - dist / 90) * 0.75 : 0;
      const beam = angleFalloff * distFalloff;

      return Math.min(1, Math.max(0.12, nearReveal + beam * 1.1));
    }

    function draw() {
      const shake = state.settings.quality === "low" ? 0 : state.screenShake;
      const sx = (Math.random() - 0.5) * shake;
      const sy = (Math.random() - 0.5) * shake;
      ctx.save();
      ctx.translate(sx, sy);
      ctx.clearRect(-40, -40, canvas.width + 80, canvas.height + 80);

      const darkTheme = document.documentElement.getAttribute("data-theme") === "dark";
      const inMetro = state.biome === "metro";
      const skyA = inMetro
        ? (darkTheme ? "#05070e" : "#9bafc4")
        : (darkTheme ? "#030718" : "#d6f3ff");
      const skyB = inMetro
        ? (darkTheme ? "#0d1118" : "#6d8798")
        : (darkTheme ? "#091427" : "#b6e7ff");

      const skyGrad = ctx.createLinearGradient(0, 0, 0, canvas.height);
      skyGrad.addColorStop(0, skyA);
      skyGrad.addColorStop(1, skyB);
      ctx.fillStyle = skyGrad;
      ctx.fillRect(0, 0, canvas.width, canvas.height);

      drawGrid();

      const p = state.player;
      const aimAngle = getPlayerAimAngle();
      const css = getComputedStyle(document.documentElement);
      const primary = css.getPropertyValue("--primary").trim();
      const secondary = css.getPropertyValue("--secondary").trim();

      if (state.playerIframes <= 0 || state.playerIframes % 4 < 2) {
        drawPlayerModel(p, primary, aimAngle);
      }

      for (const s of state.playerShots) {
        drawGroundShadow(s.x, s.y + s.r + 2, s.r * 1.15, s.r * 0.48);
        ctx.save();
        const pshot = ctx.createRadialGradient(s.x - 1, s.y - 1, 1, s.x, s.y, s.r * 1.6);
        pshot.addColorStop(0, "#ffffff");
        pshot.addColorStop(0.35, "#8be6ff");
        pshot.addColorStop(1, "#1a82a8");
        ctx.fillStyle = pshot;
        ctx.shadowBlur = 10;
        ctx.shadowColor = "#8be6ff";
        ctx.beginPath();
        ctx.arc(s.x, s.y, s.r, 0, Math.PI * 2);
        ctx.fill();
        ctx.restore();
      }

      for (const pickup of state.pickups) {
        drawGroundShadow(pickup.x, pickup.y + pickup.r + 5, pickup.r * 1.1, pickup.r * 0.45);
        ctx.save();
        const pick = ctx.createRadialGradient(
          pickup.x - pickup.r * 0.3,
          pickup.y - pickup.r * 0.45,
          1,
          pickup.x,
          pickup.y,
          pickup.r * 1.1
        );
        pick.addColorStop(0, "#f3fff9");
        pick.addColorStop(0.35, pickup.color || "#8effcf");
        pick.addColorStop(1, "#1d7f65");
        ctx.fillStyle = pick;
        ctx.shadowBlur = 14;
        ctx.shadowColor = "#8effcf";
        ctx.beginPath();
        ctx.arc(pickup.x, pickup.y, pickup.r, 0, Math.PI * 2);
        ctx.fill();
        ctx.fillStyle = "#ffffffcc";
        ctx.beginPath();
        ctx.arc(pickup.x - pickup.r * 0.32, pickup.y - pickup.r * 0.38, pickup.r * 0.2, 0, Math.PI * 2);
        ctx.fill();
        ctx.restore();
      }

      for (const e of state.enemies) {
        const visibility = getEnemyVisibility(e);
        ctx.save();
        ctx.globalAlpha = visibility;
        if (e.type === "drone") {
          drawDroneModel(e, secondary);
          if ((e.blink || 0) < 16) {
            ctx.strokeStyle = "rgba(255, 220, 160, 0.75)";
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.arc(e.x, e.y, e.r + 6, 0, Math.PI * 2);
            ctx.stroke();
          }
        } else if (e.type === "mutant") {
          drawMutantModel(e);
        } else if (e.type === "boss") {
          drawBossModel(e);
        } else {
          drawTurretModel(e);
          ctx.save();
          ctx.globalAlpha = visibility;
          if (e.lock > 0) {
            ctx.strokeStyle = "#ffdf84";
            ctx.lineWidth = 1.5;
            ctx.beginPath();
            ctx.moveTo(e.x, e.y);
            ctx.lineTo(e.aimX, e.aimY);
            ctx.stroke();
          }
          ctx.restore();
        }
        if (e.hp > 0) {
          ctx.fillStyle = "rgba(14,22,40,0.75)";
          ctx.fillRect(e.x - e.r, e.y - e.r - 10, e.r * 2, 4);
          ctx.fillStyle = e.type === "boss" ? "#ff83a9" : "#8adfff";
          const maxHp = e.type === "boss" ? (30 + state.missionsCompleted * 6) : (e.type === "mutant" ? 5 : 4);
          ctx.fillRect(e.x - e.r, e.y - e.r - 10, e.r * 2 * Math.max(0, Math.min(1, e.hp / maxHp)), 4);
        }
        ctx.restore();
      }

      for (const s of state.shots) {
        drawGroundShadow(s.x + 1, s.y + s.r + 3, s.r * 1.3, s.r * 0.55);
        ctx.save();
        const shot = ctx.createRadialGradient(s.x - 1.5, s.y - 1.5, 1, s.x, s.y, s.r * 1.8);
        shot.addColorStop(0, "#fff7db");
        shot.addColorStop(0.4, "#ffc966");
        shot.addColorStop(1, "#8f4f13");
        ctx.fillStyle = shot;
        ctx.shadowBlur = 13;
        ctx.shadowColor = "#ffc966";
        ctx.beginPath();
        ctx.arc(s.x, s.y, s.r, 0, Math.PI * 2);
        ctx.fill();
        ctx.restore();
      }

      for (const w of state.weatherEvents) {
        if (w.type === "storm") {
          if (w.warn > 0) {
            ctx.fillStyle = "#f8df5945";
            ctx.fillRect(w.x - w.width * 0.5, 0, w.width, canvas.height);
          } else {
            ctx.fillStyle = "#ffe99195";
            ctx.fillRect(w.x - 3, 0, 6, canvas.height);
            ctx.strokeStyle = "#fff7d6";
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(w.x, 0);
            ctx.lineTo(w.x + Math.sin(state.tick * 0.5) * 8, canvas.height);
            ctx.stroke();
          }
        } else {
          const cloud = ctx.createRadialGradient(w.x, w.y, 10, w.x, w.y, w.r);
          cloud.addColorStop(0, "rgba(122, 228, 142, 0.34)");
          cloud.addColorStop(1, "rgba(122, 228, 142, 0)");
          ctx.fillStyle = cloud;
          ctx.beginPath();
          ctx.arc(w.x, w.y, w.r, 0, Math.PI * 2);
          ctx.fill();
        }
      }

      if (state.extraction) {
        const e = state.extraction;
        const pulse = 0.25 + 0.2 * Math.sin(state.tick * 0.12);
        ctx.save();
        ctx.strokeStyle = "#9be9ff";
        ctx.fillStyle = `rgba(126, 220, 255, ${0.12 + pulse})`;
        ctx.lineWidth = 2;
        ctx.fillRect(e.x, e.y, e.w, e.h);
        ctx.strokeRect(e.x, e.y, e.w, e.h);
        ctx.setLineDash([6, 4]);
        ctx.strokeRect(e.x - 8, e.y - 8, e.w + 16, e.h + 16);
        ctx.setLineDash([]);
        ctx.fillStyle = "#d9f6ff";
        ctx.font = "700 16px Chakra Petch, sans-serif";
        ctx.fillText("EXTRACTION", e.x + 10, e.y - 12);
        ctx.restore();
      }

      for (const part of state.particles) {
        ctx.save();
        ctx.globalAlpha = Math.max(0, part.life / 35);
        ctx.fillStyle = part.color;
        ctx.beginPath();
        ctx.arc(part.x, part.y, 2.2, 0, Math.PI * 2);
        ctx.fill();
        ctx.restore();
      }

      ctx.fillStyle = darkTheme ? "#d9f4ff" : "#12213f";
      ctx.font = "700 25px Orbitron, sans-serif";
      ctx.fillText(`Score ${Math.floor(state.score)}`, 18, 38);
      ctx.fillText(`Best ${state.best}`, 18, 72);
      ctx.font = "700 18px Chakra Petch, sans-serif";
      ctx.fillText(zoneName(), 18, 102);
      ctx.fillText(`Battery ${Math.round(state.battery)}%`, 18, 124);
      ctx.fillText(`Missions ${state.missionsCompleted}`, 18, 146);
      ctx.fillText(`Difficulty x${state.difficulty.toFixed(2)}`, 18, 168);

      if (state.extraction) {
        const e = state.extraction;
        const barX = canvas.width - 250;
        const barY = 18;
        const barW = 220;
        const holdPct = e.hold / e.holdNeed;
        ctx.fillStyle = darkTheme ? "#0f1a2f" : "#c6dbf0";
        ctx.fillRect(barX, barY, barW, 14);
        ctx.fillStyle = "#8adfff";
        ctx.fillRect(barX, barY, barW * holdPct, 14);
        ctx.strokeStyle = darkTheme ? "#cbf4ff" : "#24508b";
        ctx.strokeRect(barX, barY, barW, 14);
        ctx.fillStyle = darkTheme ? "#dff8ff" : "#13254a";
        ctx.font = "700 14px Chakra Petch, sans-serif";
        ctx.fillText(`Extraction hold ${Math.floor(holdPct * 100)}%`, barX, barY + 30);
      }

      if (state.biome === "metro") {
        const torch = getTorchParams();
        const lightStrength = torch.range;
        const angle = torch.angle;
        const spread = torch.spread;
        const flicker = 0.92 + Math.sin(state.tick * 0.24) * 0.03;
        const beamStrength = (0.42 + state.battery / 190) * flicker;

        ctx.save();
        ctx.fillStyle = darkTheme ? "rgba(3, 7, 12, 0.48)" : "rgba(29, 43, 74, 0.36)";
        ctx.fillRect(0, 0, canvas.width, canvas.height);

        ctx.globalCompositeOperation = "screen";
        ctx.save();
        ctx.beginPath();
        ctx.moveTo(p.x, p.y);
        ctx.arc(p.x, p.y, lightStrength, angle - spread, angle + spread);
        ctx.closePath();
        ctx.clip();

        const beamX = p.x + Math.cos(angle) * lightStrength * 0.62;
        const beamY = p.y + Math.sin(angle) * lightStrength * 0.62;
        const beam = ctx.createRadialGradient(p.x, p.y, 10, beamX, beamY, lightStrength);
        beam.addColorStop(0, `rgba(255, 244, 212, ${0.55 * beamStrength})`);
        beam.addColorStop(0.35, `rgba(196, 228, 255, ${0.42 * beamStrength})`);
        beam.addColorStop(0.72, `rgba(118, 186, 255, ${0.2 * beamStrength})`);
        beam.addColorStop(1, "rgba(0, 0, 0, 0)");
        ctx.fillStyle = beam;
        ctx.fillRect(p.x - lightStrength, p.y - lightStrength, lightStrength * 2, lightStrength * 2);
        ctx.restore();

        const nearGlow = ctx.createRadialGradient(p.x, p.y, 0, p.x, p.y, 110 + state.battery * 0.65);
        nearGlow.addColorStop(0, "rgba(255, 250, 228, 0.55)");
        nearGlow.addColorStop(0.42, "rgba(220, 241, 255, 0.24)");
        nearGlow.addColorStop(1, "rgba(0, 0, 0, 0)");
        ctx.fillStyle = nearGlow;
        ctx.beginPath();
        ctx.arc(p.x, p.y, 110 + state.battery * 0.65, 0, Math.PI * 2);
        ctx.fill();

        ctx.globalCompositeOperation = "source-over";
        ctx.strokeStyle = `rgba(201, 233, 255, ${0.22 + state.battery / 420})`;
        ctx.lineWidth = 1.2;
        ctx.beginPath();
        ctx.moveTo(p.x, p.y);
        ctx.lineTo(
          p.x + Math.cos(angle) * (lightStrength * 0.9),
          p.y + Math.sin(angle) * (lightStrength * 0.9)
        );
        ctx.stroke();
        ctx.restore();
      }

      if (!state.running) {
        ctx.fillStyle = darkTheme ? "#000000b8" : "#d8eeffbf";
        ctx.fillRect(0, 0, canvas.width, canvas.height);

        ctx.fillStyle = darkTheme ? "#fff" : "#112447";
        ctx.textAlign = "center";
        ctx.font = "800 56px Orbitron, sans-serif";
        ctx.fillText("Flatlined", canvas.width / 2, canvas.height / 2 - 24);
        ctx.font = "700 24px Chakra Petch, sans-serif";
        const reason = state.cause ? `Cause: ${state.cause}` : "Press R or Restart";
        ctx.fillText(reason, canvas.width / 2, canvas.height / 2 + 20);
        ctx.fillText("Press R or Restart", canvas.width / 2, canvas.height / 2 + 54);
        ctx.fillText(`Missions completed: ${state.missionsCompleted}`, canvas.width / 2, canvas.height / 2 + 88);
        ctx.fillText(`Scrap: ${state.scrap} | Upgrades: [1]DMG [2]HP [3]DASH`, canvas.width / 2, canvas.height / 2 + 120);
        ctx.textAlign = "left";
      }

      if (state.hitFlash > 0) {
        ctx.fillStyle = `rgba(255, 52, 90, ${state.hitFlash * 0.28})`;
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        const hx = state.player.x + Math.cos(state.lastHitAngle) * 52;
        const hy = state.player.y + Math.sin(state.lastHitAngle) * 52;
        ctx.strokeStyle = "rgba(255,120,145,0.9)";
        ctx.lineWidth = 3;
        ctx.beginPath();
        ctx.moveTo(state.player.x, state.player.y);
        ctx.lineTo(hx, hy);
        ctx.stroke();
      }

      ctx.restore();
    }

    function frame() {
      drawMatrix();
      update();
      draw();
      requestAnimationFrame(frame);
    }

    window.addEventListener("keydown", (event) => {
      const key = event.key.toLowerCase();
      state.keys.add(key);
      if (isFireKey(key)) {
        event.preventDefault();
        state.firing = true;
      }
      if (isDashKey(key)) {
        event.preventDefault();
        triggerDash();
      }
      if (key === "q") {
        cycleWeapon();
      }
      if (!state.running && key === "1") tryUpgrade("damage");
      if (!state.running && key === "2") tryUpgrade("maxHealth");
      if (!state.running && key === "3") tryUpgrade("dash");
      if (!state.running && key === "r") reset();
    });

    window.addEventListener("keyup", (event) => {
      const key = event.key.toLowerCase();
      state.keys.delete(key);
      if (isFireKey(key)) {
        state.firing = false;
      }
    });

    canvas.addEventListener("mousemove", (event) => {
      const rect = canvas.getBoundingClientRect();
      const scaleX = canvas.width / rect.width;
      const scaleY = canvas.height / rect.height;
      state.player.aimX = (event.clientX - rect.left) * scaleX;
      state.player.aimY = (event.clientY - rect.top) * scaleY;
    });

    canvas.addEventListener("mousedown", () => {
      state.firing = true;
    });

    window.addEventListener("mouseup", () => {
      state.firing = false;
    });

    touchUi.querySelectorAll("[data-key]").forEach((btn) => {
      const key = btn.dataset.key;
      const down = (ev) => {
        ev.preventDefault();
        state.keys.add(key);
      };
      const up = (ev) => {
        ev.preventDefault();
        state.keys.delete(key);
      };
      btn.addEventListener("touchstart", down, { passive: false });
      btn.addEventListener("touchend", up, { passive: false });
      btn.addEventListener("mousedown", down);
      btn.addEventListener("mouseup", up);
      btn.addEventListener("mouseleave", up);
    });

    touchFire.addEventListener("touchstart", (ev) => { ev.preventDefault(); state.firing = true; }, { passive: false });
    touchFire.addEventListener("touchend", (ev) => { ev.preventDefault(); state.firing = false; }, { passive: false });
    touchFire.addEventListener("mousedown", () => { state.firing = true; });
    touchFire.addEventListener("mouseup", () => { state.firing = false; });
    touchDash.addEventListener("touchstart", (ev) => { ev.preventDefault(); triggerDash(); }, { passive: false });
    touchDash.addEventListener("mousedown", () => { triggerDash(); });

    restartButton.addEventListener("click", reset);

    settingsBtn.addEventListener("click", () => {
      settingsPanel.classList.toggle("open");
    });

    themeSelect.addEventListener("change", (event) => {
      setTheme(event.target.value);
    });

    biomeSelect.addEventListener("change", (event) => {
      applyBiomeMode(event.target.value);
    });

    musicSelect.addEventListener("change", (event) => {
      const trackName = event.target.value;
      if (trackName === "off") {
        stopMusic();
      } else {
        startMusic(trackName);
      }
    });

    sfxVolume.addEventListener("input", () => {
      state.settings.sfxVolume = Number(sfxVolume.value) / 100;
      applySettingsToRuntime();
      saveSettings();
    });
    musicVolume.addEventListener("input", () => {
      state.settings.musicVolume = Number(musicVolume.value) / 100;
      applySettingsToRuntime();
      saveSettings();
    });
    qualityMode.addEventListener("change", () => {
      state.settings.quality = qualityMode.value;
      saveSettings();
    });
    colorblindMode.addEventListener("change", () => {
      state.settings.colorblind = colorblindMode.value;
      applySettingsToRuntime();
      saveSettings();
    });
    fireKeyInput.addEventListener("change", () => {
      const v = fireKeyInput.value.toLowerCase().trim() || "f";
      state.settings.fireKey = v;
      saveSettings();
    });
    dashKeyInput.addEventListener("change", () => {
      const v = dashKeyInput.value.toLowerCase().trim() || "shift";
      state.settings.dashKey = v;
      saveSettings();
    });

    const savedTheme = localStorage.getItem(THEME_KEY);
    setTheme(savedTheme === "bright" ? "bright" : "dark");
    const savedBiomeMode = localStorage.getItem(BIOME_MODE_KEY);
    applyBiomeMode(savedBiomeMode === "city" || savedBiomeMode === "metro" ? savedBiomeMode : "auto");
    loadSettings();
    applySettingsToRuntime();
    state.healthMax = 100 + state.upgrades.maxHealth * 12;
    state.health = state.healthMax;
    state.dash.staminaMax = 100 + state.upgrades.dash * 14;
    state.dash.stamina = state.dash.staminaMax;
    applyWeaponProfile(state.weapon.type);
    chooseMission();
    resizeMatrix();
    updateHud();
    window.addEventListener("resize", resizeMatrix);

    frame();
  </script>
</body>
</html>
